#pragma version 10
#pragma typetrack false

// smart_contracts.open_ballot.contract.OpenBallot.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 16900 1000 TMPL_VERSION_UNIX TMPL_DELETABLE
    bytecblock 0x615f "total_purged_box_a_" "poll_finalized" "total_choice1" "total_choice2" "total_choice3" "poll_end_date_unix" 0x0000
    // smart_contracts/open_ballot/contract.py:25
    // class OpenBallot(ARC4Contract):
    txn NumAppArgs
    bz main_after_if_else@14
    pushbytess 0x5be219f0 0x81e1658f 0xe6bf4f23 0xfe7b6e39 0x8c2ecf22 0x761dd0fa 0x6e0b83b9 0xbdefdf45 0x5ff16da4 // method "generate()void", method "get_version_unix()uint64", method "set_poll(byte[],byte[],byte[],byte[],uint64,uint64)void", method "fund_app_mbr(pay)void", method "request_box_storage(pay)void", method "submit_vote(uint8)void", method "delete_box_storage()void", method "purge_box_storage(address[])void", method "terminate()void"
    txna ApplicationArgs 0
    match main_generate_route@5 main_get_version_unix_route@6 main_set_poll_route@7 main_fund_app_mbr_route@8 main_request_box_storage_route@9 main_submit_vote_route@10 main_delete_box_storage_route@11 main_purge_box_storage_route@12 main_terminate_route@13

main_after_if_else@14:
    // smart_contracts/open_ballot/contract.py:25
    // class OpenBallot(ARC4Contract):
    intc_1 // 0
    return

main_terminate_route@13:
    // smart_contracts/open_ballot/contract.py:401-402
    // # Allow application creator to delete the smart contract client, decrease their MBR balance + any remaining box MBR
    // @arc4.abimethod(create="disallow", allow_actions=["DeleteApplication"])
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub terminate
    intc_0 // 1
    return

main_purge_box_storage_route@12:
    // smart_contracts/open_ballot/contract.py:366-367
    // # Enable application creator to execute box storage purge, this deletes any boxes not deleted by other accounts
    // @arc4.abimethod  # NOTE: Can also use arc4.StaticArray[arc4.Address, t.Literal[8]] to enforce strict size of 8
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/open_ballot/contract.py:25
    // class OpenBallot(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/open_ballot/contract.py:366-367
    // # Enable application creator to execute box storage purge, this deletes any boxes not deleted by other accounts
    // @arc4.abimethod  # NOTE: Can also use arc4.StaticArray[arc4.Address, t.Literal[8]] to enforce strict size of 8
    callsub purge_box_storage
    intc_0 // 1
    return

main_delete_box_storage_route@11:
    // smart_contracts/open_ballot/contract.py:327-328
    // # Enable any eligble account to delete their box storage and get their MBR payment refunded
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub delete_box_storage
    intc_0 // 1
    return

main_submit_vote_route@10:
    // smart_contracts/open_ballot/contract.py:274-275
    // # Enable any eligible account to submit a vote
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/open_ballot/contract.py:25
    // class OpenBallot(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/open_ballot/contract.py:274-275
    // # Enable any eligible account to submit a vote
    // @arc4.abimethod
    callsub submit_vote
    intc_0 // 1
    return

main_request_box_storage_route@9:
    // smart_contracts/open_ballot/contract.py:240-241
    // # Enable any eligible account to request box storage by paying a MBR cost
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/open_ballot/contract.py:25
    // class OpenBallot(ARC4Contract):
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/open_ballot/contract.py:240-241
    // # Enable any eligible account to request box storage by paying a MBR cost
    // @arc4.abimethod
    callsub request_box_storage
    intc_0 // 1
    return

main_fund_app_mbr_route@8:
    // smart_contracts/open_ballot/contract.py:199-200
    // # Enable application creator to fund App address and covers its Global minimum balance and Box storage MBR
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/open_ballot/contract.py:25
    // class OpenBallot(ARC4Contract):
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/open_ballot/contract.py:199-200
    // # Enable application creator to fund App address and covers its Global minimum balance and Box storage MBR
    // @arc4.abimethod
    callsub fund_app_mbr
    intc_0 // 1
    return

main_set_poll_route@7:
    // smart_contracts/open_ballot/contract.py:139-140
    // # Enable application creator to set up poll data values including title, choices, and dates
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/open_ballot/contract.py:25
    // class OpenBallot(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    extract 2 0
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    // smart_contracts/open_ballot/contract.py:139-140
    // # Enable application creator to set up poll data values including title, choices, and dates
    // @arc4.abimethod
    callsub set_poll
    intc_0 // 1
    return

main_get_version_unix_route@6:
    // smart_contracts/open_ballot/contract.py:133-134
    // # Retrieve the version of the smart contract in an Unix format timestamp
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/open_ballot/contract.py:136
    // return TemplateVar[UInt64]("VERSION_UNIX")
    intc 4 // TMPL_VERSION_UNIX
    // smart_contracts/open_ballot/contract.py:133-134
    // # Retrieve the version of the smart contract in an Unix format timestamp
    // @arc4.abimethod
    itob
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_generate_route@5:
    // smart_contracts/open_ballot/contract.py:108-109
    // # Call the 'Create' abimethod that generates the smart contract client and initializes global storage int variables
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub generate
    intc_0 // 1
    return


// smart_contracts.open_ballot.contract.OpenBallot.generate() -> void:
generate:
    // smart_contracts/open_ballot/contract.py:108-110
    // # Call the 'Create' abimethod that generates the smart contract client and initializes global storage int variables
    // @arc4.abimethod(create="require")
    // def generate(self) -> None:
    proto 0 0
    // smart_contracts/open_ballot/contract.py:113
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/open_ballot/contract.py:111-114
    // # Make necessary assertions to verify transaction requirements
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Transaction sender address must match application creator address."
    assert // Transaction sender address must match application creator address.
    // smart_contracts/open_ballot/contract.py:116
    // assert Global.creator_address.balance >= (
    global CreatorAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/open_ballot/contract.py:117
    // Global.min_balance
    global MinBalance
    // smart_contracts/open_ballot/contract.py:75-76
    // # Return the minimum balance requirement total cost
    // return base_fee + total_byte_fee + total_uint_fee
    pushint 499500 // 499500
    // smart_contracts/open_ballot/contract.py:117-120
    // Global.min_balance
    // + self.calc_schema_mbr(
    //     num_bytes=UInt64(4), num_uint=UInt64(7)
    // )  # Global schema MBR: 0.1 (Global.min_balance) + 0.3995 ALGO (Global schema)
    +
    // smart_contracts/open_ballot/contract.py:116-120
    // assert Global.creator_address.balance >= (
    //     Global.min_balance
    //     + self.calc_schema_mbr(
    //         num_bytes=UInt64(4), num_uint=UInt64(7)
    //     )  # Global schema MBR: 0.1 (Global.min_balance) + 0.3995 ALGO (Global schema)
    >=
    // smart_contracts/open_ballot/contract.py:116-121
    // assert Global.creator_address.balance >= (
    //     Global.min_balance
    //     + self.calc_schema_mbr(
    //         num_bytes=UInt64(4), num_uint=UInt64(7)
    //     )  # Global schema MBR: 0.1 (Global.min_balance) + 0.3995 ALGO (Global schema)
    // ), "Application creator address balance must be equal or greater than Global.min_balance + Global schema MBR."
    assert // Application creator address balance must be equal or greater than Global.min_balance + Global schema MBR.
    // smart_contracts/open_ballot/contract.py:123-124
    // # Initialize Global storage with default value assignments
    // self.poll_finalized = UInt64(0)
    bytec_2 // "poll_finalized"
    intc_1 // 0
    app_global_put
    // smart_contracts/open_ballot/contract.py:126
    // self.total_choice1 = UInt64(0)
    bytec_3 // "total_choice1"
    intc_1 // 0
    app_global_put
    // smart_contracts/open_ballot/contract.py:127
    // self.total_choice2 = UInt64(0)
    bytec 4 // "total_choice2"
    intc_1 // 0
    app_global_put
    // smart_contracts/open_ballot/contract.py:128
    // self.total_choice3 = UInt64(0)
    bytec 5 // "total_choice3"
    intc_1 // 0
    app_global_put
    // smart_contracts/open_ballot/contract.py:130
    // self.total_purged_box_a_ = UInt64(0)
    bytec_1 // "total_purged_box_a_"
    intc_1 // 0
    app_global_put
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.set_poll(title: bytes, choice1: bytes, choice2: bytes, choice3: bytes, start_date_unix: uint64, end_date_unix: uint64) -> void:
set_poll:
    // smart_contracts/open_ballot/contract.py:139-149
    // # Enable application creator to set up poll data values including title, choices, and dates
    // @arc4.abimethod
    // def set_poll(
    //     self,
    //     title: Bytes,
    //     choice1: Bytes,
    //     choice2: Bytes,
    //     choice3: Bytes,
    //     start_date_unix: UInt64,
    //     end_date_unix: UInt64,
    // ) -> None:
    proto 6 0
    // smart_contracts/open_ballot/contract.py:152
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/open_ballot/contract.py:150-153
    // # Make necessary assertions to verify transaction requirements
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Only application creator can set up poll."
    assert // Only application creator can set up poll.
    // smart_contracts/open_ballot/contract.py:155
    // assert title.length <= UInt64(
    frame_dig -6
    len
    // smart_contracts/open_ballot/contract.py:155-157
    // assert title.length <= UInt64(
    //     118
    // ), "Poll title size can not exceed 118 bytes of data per key-value."
    pushint 118 // 118
    <=
    assert // Poll title size can not exceed 118 bytes of data per key-value.
    // smart_contracts/open_ballot/contract.py:160
    // choice1.length <= UInt64(116)
    frame_dig -5
    len
    pushint 116 // 116
    <=
    // smart_contracts/open_ballot/contract.py:160-162
    // choice1.length <= UInt64(116)
    // and choice2.length <= UInt64(116)
    // and choice3.length <= UInt64(116)
    bz set_poll_bool_false@4
    // smart_contracts/open_ballot/contract.py:161
    // and choice2.length <= UInt64(116)
    frame_dig -4
    len
    pushint 116 // 116
    <=
    // smart_contracts/open_ballot/contract.py:160-162
    // choice1.length <= UInt64(116)
    // and choice2.length <= UInt64(116)
    // and choice3.length <= UInt64(116)
    bz set_poll_bool_false@4
    // smart_contracts/open_ballot/contract.py:162
    // and choice3.length <= UInt64(116)
    frame_dig -3
    len
    pushint 116 // 116
    <=
    // smart_contracts/open_ballot/contract.py:160-162
    // choice1.length <= UInt64(116)
    // and choice2.length <= UInt64(116)
    // and choice3.length <= UInt64(116)
    bz set_poll_bool_false@4
    intc_0 // 1

set_poll_bool_merge@5:
    // smart_contracts/open_ballot/contract.py:159-163
    // assert (
    //     choice1.length <= UInt64(116)
    //     and choice2.length <= UInt64(116)
    //     and choice3.length <= UInt64(116)
    // ), "Poll choice size cannot exceed 116 bytes of data per key-value."
    assert // Poll choice size cannot exceed 116 bytes of data per key-value.
    // smart_contracts/open_ballot/contract.py:174
    // start_date_unix < end_date_unix
    frame_dig -2
    frame_dig -1
    <
    // smart_contracts/open_ballot/contract.py:173-175
    // assert (
    //     start_date_unix < end_date_unix
    // ), "Start date must be earlier than end date."
    assert // Start date must be earlier than end date.
    // smart_contracts/open_ballot/contract.py:177-179
    // assert end_date_unix >= start_date_unix + UInt64(
    //     3 * 24 * 60 * 60
    // ), "End date must be at least 3 days later than the start date."
    frame_dig -2
    pushint 259200 // 259200
    +
    frame_dig -1
    <=
    assert // End date must be at least 3 days later than the start date.
    // smart_contracts/open_ballot/contract.py:181
    // assert end_date_unix - start_date_unix <= UInt64(
    frame_dig -1
    frame_dig -2
    -
    // smart_contracts/open_ballot/contract.py:181-183
    // assert end_date_unix - start_date_unix <= UInt64(
    //     14 * 24 * 60 * 60
    // ), "Voting period can not exceed 14 days."
    pushint 1209600 // 1209600
    <=
    assert // Voting period can not exceed 14 days.
    // smart_contracts/open_ballot/contract.py:185
    // assert self.poll_finalized == UInt64(0), "Poll can only be setup once."
    intc_1 // 0
    bytec_2 // "poll_finalized"
    app_global_get_ex
    assert // check self.poll_finalized exists
    !
    assert // Poll can only be setup once.
    // smart_contracts/open_ballot/contract.py:187-188
    // # Update global state keys with new values
    // self.poll_title = title
    pushbytes "poll_title"
    frame_dig -6
    app_global_put
    // smart_contracts/open_ballot/contract.py:189
    // self.poll_choice1 = choice1
    pushbytes "poll_choice1"
    frame_dig -5
    app_global_put
    // smart_contracts/open_ballot/contract.py:190
    // self.poll_choice2 = choice2
    pushbytes "poll_choice2"
    frame_dig -4
    app_global_put
    // smart_contracts/open_ballot/contract.py:191
    // self.poll_choice3 = choice3
    pushbytes "poll_choice3"
    frame_dig -3
    app_global_put
    // smart_contracts/open_ballot/contract.py:192
    // self.poll_start_date_unix = start_date_unix
    pushbytes "poll_start_date_unix"
    frame_dig -2
    app_global_put
    // smart_contracts/open_ballot/contract.py:193
    // self.poll_end_date_unix = end_date_unix
    bytec 6 // "poll_end_date_unix"
    frame_dig -1
    app_global_put
    // smart_contracts/open_ballot/contract.py:195-196
    // # Finalize poll (ensures poll can only be set once)
    // self.poll_finalized = UInt64(1)
    bytec_2 // "poll_finalized"
    intc_0 // 1
    app_global_put
    retsub

set_poll_bool_false@4:
    intc_1 // 0
    b set_poll_bool_merge@5


// smart_contracts.open_ballot.contract.OpenBallot.fund_app_mbr(mbr_pay: uint64) -> void:
fund_app_mbr:
    // smart_contracts/open_ballot/contract.py:199-201
    // # Enable application creator to fund App address and covers its Global minimum balance and Box storage MBR
    // @arc4.abimethod
    // def fund_app_mbr(self, mbr_pay: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/open_ballot/contract.py:204
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/open_ballot/contract.py:202-205
    // # Make necessary assertions to verify transaction requirements
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Transaction sender address must match application creator address."
    assert // Transaction sender address must match application creator address.
    // smart_contracts/open_ballot/contract.py:208
    // Txn.sender not in self.box_a_voter_data
    bytec_0 // 0x615f
    txn Sender
    concat
    box_len
    bury 1
    !
    // smart_contracts/open_ballot/contract.py:207-209
    // assert (
    //     Txn.sender not in self.box_a_voter_data
    // ), "Transaction sender address already present in box a_."
    assert // Transaction sender address already present in box a_.
    // smart_contracts/open_ballot/contract.py:212
    // mbr_pay.sender == Global.creator_address
    frame_dig -1
    gtxns Sender
    global CreatorAddress
    ==
    // smart_contracts/open_ballot/contract.py:211-213
    // assert (
    //     mbr_pay.sender == Global.creator_address
    // ), "MBR payment sender address must match appplication creator address."
    assert // MBR payment sender address must match appplication creator address.
    // smart_contracts/open_ballot/contract.py:216
    // mbr_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/open_ballot/contract.py:215-217
    // assert (
    //     mbr_pay.receiver == Global.current_application_address
    // ), "MBR payment reciever address must match application address."
    assert // MBR payment reciever address must match application address.
    // smart_contracts/open_ballot/contract.py:220
    // mbr_pay.amount
    frame_dig -1
    gtxns Amount
    // smart_contracts/open_ballot/contract.py:91-92
    // # Return single box fee
    // return base_fee.native + size_fee
    intc_2 // 16900
    // smart_contracts/open_ballot/contract.py:220-221
    // mbr_pay.amount
    // >= self.calc_box_storage_mbr()  # Box Storage MBR: 0.0169 ALGO
    >=
    // smart_contracts/open_ballot/contract.py:219-222
    // assert (
    //     mbr_pay.amount
    //     >= self.calc_box_storage_mbr()  # Box Storage MBR: 0.0169 ALGO
    // ), "MBR payment for box storage must meet the minimum requirement amount."
    assert // MBR payment for box storage must meet the minimum requirement amount.
    // smart_contracts/open_ballot/contract.py:224
    // assert Global.current_application_address.balance >= (
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/open_ballot/contract.py:225
    // Global.min_balance + self.calc_box_storage_mbr()
    global MinBalance
    // smart_contracts/open_ballot/contract.py:91-92
    // # Return single box fee
    // return base_fee.native + size_fee
    intc_2 // 16900
    // smart_contracts/open_ballot/contract.py:225
    // Global.min_balance + self.calc_box_storage_mbr()
    +
    // smart_contracts/open_ballot/contract.py:224-225
    // assert Global.current_application_address.balance >= (
    //     Global.min_balance + self.calc_box_storage_mbr()
    >=
    // smart_contracts/open_ballot/contract.py:224-226
    // assert Global.current_application_address.balance >= (
    //     Global.min_balance + self.calc_box_storage_mbr()
    // ), "Application address balance must be equal or greater than Global.min_balance + Box storage fee."
    assert // Application address balance must be equal or greater than Global.min_balance + Box storage fee.
    // smart_contracts/open_ballot/contract.py:229
    // Global.latest_timestamp <= self.poll_end_date_unix
    global LatestTimestamp
    intc_1 // 0
    bytec 6 // "poll_end_date_unix"
    app_global_get_ex
    assert // check self.poll_end_date_unix exists
    <=
    // smart_contracts/open_ballot/contract.py:228-230
    // assert (
    //     Global.latest_timestamp <= self.poll_end_date_unix
    // ), "Unable to fund app mbr if voting period is over."
    assert // Unable to fund app mbr if voting period is over.
    // smart_contracts/open_ballot/contract.py:232-234
    // # Check if voter data box doesn't already exist, if not (False) then create new one
    // # if not self.box_a_voter_data.maybe(Txn.sender)[1]: <- This works too if copy() used
    // if Global.creator_address not in self.box_a_voter_data:
    bytec_0 // 0x615f
    global CreatorAddress
    concat
    box_len
    bury 1
    bnz fund_app_mbr_after_if_else@2
    // smart_contracts/open_ballot/contract.py:235
    // self.box_a_voter_data[Global.creator_address] = VoterData(
    bytec_0 // 0x615f
    global CreatorAddress
    concat
    // smart_contracts/open_ballot/contract.py:235-237
    // self.box_a_voter_data[Global.creator_address] = VoterData(
    //     arc4.UInt8(0), arc4.UInt8(0)
    // )
    bytec 7 // 0x0000
    box_put

fund_app_mbr_after_if_else@2:
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.request_box_storage(mbr_pay: uint64) -> void:
request_box_storage:
    // smart_contracts/open_ballot/contract.py:240-242
    // # Enable any eligible account to request box storage by paying a MBR cost
    // @arc4.abimethod
    // def request_box_storage(self, mbr_pay: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/open_ballot/contract.py:245
    // Txn.sender != Global.creator_address
    txn Sender
    global CreatorAddress
    !=
    // smart_contracts/open_ballot/contract.py:243-246
    // # Make necessary assertions to verify transaction requirements
    // assert (
    //     Txn.sender != Global.creator_address
    // ), "Invalid sender address! Application creator address can not use request box storage method."
    assert // Invalid sender address! Application creator address can not use request box storage method.
    // smart_contracts/open_ballot/contract.py:249
    // Txn.sender not in self.box_a_voter_data
    bytec_0 // 0x615f
    txn Sender
    concat
    box_len
    bury 1
    !
    // smart_contracts/open_ballot/contract.py:248-250
    // assert (
    //     Txn.sender not in self.box_a_voter_data
    // ), "Transaction sender address must not be present in box a_."
    assert // Transaction sender address must not be present in box a_.
    // smart_contracts/open_ballot/contract.py:253
    // mbr_pay.sender not in self.box_a_voter_data
    frame_dig -1
    gtxns Sender
    bytec_0 // 0x615f
    swap
    concat
    box_len
    bury 1
    !
    // smart_contracts/open_ballot/contract.py:252-254
    // assert (
    //     mbr_pay.sender not in self.box_a_voter_data
    // ), "Box storage MBR payment sender address must not be present in box a_."
    assert // Box storage MBR payment sender address must not be present in box a_.
    // smart_contracts/open_ballot/contract.py:257
    // mbr_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/open_ballot/contract.py:256-258
    // assert (
    //     mbr_pay.receiver == Global.current_application_address
    // ), "Box storage MBR payment reciever address must match application address."
    assert // Box storage MBR payment reciever address must match application address.
    // smart_contracts/open_ballot/contract.py:261
    // mbr_pay.amount >= self.calc_box_storage_mbr()  # Box a_ fee: 0.0169 ALGO
    frame_dig -1
    gtxns Amount
    // smart_contracts/open_ballot/contract.py:91-92
    // # Return single box fee
    // return base_fee.native + size_fee
    intc_2 // 16900
    // smart_contracts/open_ballot/contract.py:261
    // mbr_pay.amount >= self.calc_box_storage_mbr()  # Box a_ fee: 0.0169 ALGO
    >=
    // smart_contracts/open_ballot/contract.py:260-262
    // assert (
    //     mbr_pay.amount >= self.calc_box_storage_mbr()  # Box a_ fee: 0.0169 ALGO
    // ), "Box storage MBR payment amount must be equal or greater than box _a fee."
    assert // Box storage MBR payment amount must be equal or greater than box _a fee.
    // smart_contracts/open_ballot/contract.py:265
    // Global.latest_timestamp <= self.poll_end_date_unix
    global LatestTimestamp
    intc_1 // 0
    bytec 6 // "poll_end_date_unix"
    app_global_get_ex
    assert // check self.poll_end_date_unix exists
    <=
    // smart_contracts/open_ballot/contract.py:264-266
    // assert (
    //     Global.latest_timestamp <= self.poll_end_date_unix
    // ), "Unable to request box storage if voting period is over."
    assert // Unable to request box storage if voting period is over.
    // smart_contracts/open_ballot/contract.py:268-270
    // # Check if voter data box doesn't already exist, if not (False) then create new one
    // # if not self.box_a_voter_data.maybe(Txn.sender)[1]: <- This works too if copy() used
    // if Txn.sender not in self.box_a_voter_data:
    bytec_0 // 0x615f
    txn Sender
    concat
    box_len
    bury 1
    bnz request_box_storage_after_if_else@2
    // smart_contracts/open_ballot/contract.py:271
    // self.box_a_voter_data[Txn.sender] = VoterData(arc4.UInt8(0), arc4.UInt8(0))
    bytec_0 // 0x615f
    txn Sender
    concat
    bytec 7 // 0x0000
    box_put

request_box_storage_after_if_else@2:
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.submit_vote(choice: bytes) -> void:
submit_vote:
    // smart_contracts/open_ballot/contract.py:274-276
    // # Enable any eligible account to submit a vote
    // @arc4.abimethod
    // def submit_vote(self, choice: arc4.UInt8) -> None:
    proto 1 0
    // smart_contracts/open_ballot/contract.py:279
    // Txn.sender in self.box_a_voter_data
    bytec_0 // 0x615f
    txn Sender
    concat
    box_len
    bury 1
    // smart_contracts/open_ballot/contract.py:277-280
    // # Make necessary assertions to verify transaction requirements
    // assert (
    //     Txn.sender in self.box_a_voter_data
    // ), "Transaction sender address must be present in box a_."
    assert // Transaction sender address must be present in box a_.
    // smart_contracts/open_ballot/contract.py:283
    // self.box_a_voter_data[Txn.sender].voted,
    bytec_0 // 0x615f
    txn Sender
    concat
    box_get
    assert // check self.box_a_voter_data entry exists
    extract 0 1 // on error: Index access is out of bounds
    // smart_contracts/open_ballot/contract.py:286
    // arc4.UInt8(0),
    pushbytes 0x00
    // smart_contracts/open_ballot/contract.py:282-288
    // assert (
    //     self.box_a_voter_data[Txn.sender].voted,
    //     self.box_a_voter_data[Txn.sender].choice,
    // ) == (
    //     arc4.UInt8(0),
    //     arc4.UInt8(0),
    // ), "Transaction sender address already submitted a vote."
    b==
    // smart_contracts/open_ballot/contract.py:284
    // self.box_a_voter_data[Txn.sender].choice,
    bytec_0 // 0x615f
    txn Sender
    concat
    box_get
    assert // check self.box_a_voter_data entry exists
    extract 1 1 // on error: Index access is out of bounds
    // smart_contracts/open_ballot/contract.py:287
    // arc4.UInt8(0),
    pushbytes 0x00
    // smart_contracts/open_ballot/contract.py:282-288
    // assert (
    //     self.box_a_voter_data[Txn.sender].voted,
    //     self.box_a_voter_data[Txn.sender].choice,
    // ) == (
    //     arc4.UInt8(0),
    //     arc4.UInt8(0),
    // ), "Transaction sender address already submitted a vote."
    b==
    &&
    assert // Transaction sender address already submitted a vote.
    // smart_contracts/open_ballot/contract.py:291
    // choice == arc4.UInt8(1)
    frame_dig -1
    pushbytes 0x01
    b==
    // smart_contracts/open_ballot/contract.py:291-293
    // choice == arc4.UInt8(1)
    // or choice == arc4.UInt8(2)
    // or choice == arc4.UInt8(3)
    bnz submit_vote_bool_true@3
    // smart_contracts/open_ballot/contract.py:292
    // or choice == arc4.UInt8(2)
    frame_dig -1
    pushbytes 0x02
    b==
    // smart_contracts/open_ballot/contract.py:291-293
    // choice == arc4.UInt8(1)
    // or choice == arc4.UInt8(2)
    // or choice == arc4.UInt8(3)
    bnz submit_vote_bool_true@3
    // smart_contracts/open_ballot/contract.py:293
    // or choice == arc4.UInt8(3)
    frame_dig -1
    pushbytes 0x03
    b==
    // smart_contracts/open_ballot/contract.py:291-293
    // choice == arc4.UInt8(1)
    // or choice == arc4.UInt8(2)
    // or choice == arc4.UInt8(3)
    bz submit_vote_bool_false@4

submit_vote_bool_true@3:
    intc_0 // 1

submit_vote_bool_merge@5:
    // smart_contracts/open_ballot/contract.py:290-294
    // assert (
    //     choice == arc4.UInt8(1)
    //     or choice == arc4.UInt8(2)
    //     or choice == arc4.UInt8(3)
    // ), "Invalid choice. Can only select choices 1, 2, 3."
    assert // Invalid choice. Can only select choices 1, 2, 3.
    // smart_contracts/open_ballot/contract.py:315-316
    // # Set account voter data
    // self.box_a_voter_data[Txn.sender] = VoterData(arc4.UInt8(1), choice)
    pushbytes 0x01
    frame_dig -1
    concat
    bytec_0 // 0x615f
    txn Sender
    concat
    swap
    box_put
    // smart_contracts/open_ballot/contract.py:318-319
    // # Update vote tally
    // if choice == UInt64(1):
    intc_0 // 1
    itob
    frame_dig -1
    b==
    bz submit_vote_else_body@7
    // smart_contracts/open_ballot/contract.py:320
    // self.total_choice1 += UInt64(1)
    intc_1 // 0
    bytec_3 // "total_choice1"
    app_global_get_ex
    assert // check self.total_choice1 exists
    intc_0 // 1
    +
    bytec_3 // "total_choice1"
    swap
    app_global_put
    retsub

submit_vote_else_body@7:
    // smart_contracts/open_ballot/contract.py:321
    // elif choice == UInt64(2):
    pushint 2 // 2
    itob
    frame_dig -1
    b==
    bz submit_vote_else_body@9
    // smart_contracts/open_ballot/contract.py:322
    // self.total_choice2 += UInt64(1)
    intc_1 // 0
    bytec 4 // "total_choice2"
    app_global_get_ex
    assert // check self.total_choice2 exists
    intc_0 // 1
    +
    bytec 4 // "total_choice2"
    swap
    app_global_put
    retsub

submit_vote_else_body@9:
    // smart_contracts/open_ballot/contract.py:324
    // self.total_choice3 += UInt64(1)
    intc_1 // 0
    bytec 5 // "total_choice3"
    app_global_get_ex
    assert // check self.total_choice3 exists
    intc_0 // 1
    +
    bytec 5 // "total_choice3"
    swap
    app_global_put
    retsub

submit_vote_bool_false@4:
    intc_1 // 0
    b submit_vote_bool_merge@5


// smart_contracts.open_ballot.contract.OpenBallot.delete_box_storage() -> void:
delete_box_storage:
    // smart_contracts/open_ballot/contract.py:327-329
    // # Enable any eligble account to delete their box storage and get their MBR payment refunded
    // @arc4.abimethod
    // def delete_box_storage(self) -> None:
    proto 0 0
    // smart_contracts/open_ballot/contract.py:332
    // Txn.sender != Global.creator_address
    txn Sender
    global CreatorAddress
    !=
    // smart_contracts/open_ballot/contract.py:330-333
    // # Make necessary assertions to verify transaction requirements
    // assert (
    //     Txn.sender != Global.creator_address
    // ), "Invalid sender address! Application creator must delete smart contract to free up their box storage MBR."
    assert // Invalid sender address! Application creator must delete smart contract to free up their box storage MBR.
    // smart_contracts/open_ballot/contract.py:336
    // Txn.sender in self.box_a_voter_data
    bytec_0 // 0x615f
    txn Sender
    concat
    box_len
    bury 1
    // smart_contracts/open_ballot/contract.py:335-337
    // assert (
    //     Txn.sender in self.box_a_voter_data
    // ), "Transaction sender address must be present in box a_."
    assert // Transaction sender address must be present in box a_.
    // smart_contracts/open_ballot/contract.py:344-345
    // # Delete box key (address) from box storage and decrement box 'a_' total amount
    // del self.box_a_voter_data[Txn.sender]
    bytec_0 // 0x615f
    txn Sender
    concat
    box_del
    pop
    // smart_contracts/open_ballot/contract.py:349-355
    // box_storage_del_refund_itxn = itxn.Payment(
    //     sender=Global.current_application_address,
    //     receiver=Txn.sender,
    //     amount=self.calc_box_storage_mbr() - min_txn_fee,
    //     fee=min_txn_fee,
    //     note="Account gets app box storage MBR (0.0169 ALGO) refunded.",
    // ).submit()
    itxn_begin
    // smart_contracts/open_ballot/contract.py:350
    // sender=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/open_ballot/contract.py:351
    // receiver=Txn.sender,
    txn Sender
    // smart_contracts/open_ballot/contract.py:354
    // note="Account gets app box storage MBR (0.0169 ALGO) refunded.",
    pushbytes "Account gets app box storage MBR (0.0169 ALGO) refunded."
    itxn_field Note
    // smart_contracts/open_ballot/contract.py:352
    // amount=self.calc_box_storage_mbr() - min_txn_fee,
    pushint 15900 // 15900
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/open_ballot/contract.py:349
    // box_storage_del_refund_itxn = itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    // smart_contracts/open_ballot/contract.py:347-348
    // # Submit inner transaction (transaction sender gets their Box storage MBR refunded)
    // min_txn_fee = arc4.UInt16(1000).native
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/open_ballot/contract.py:349-355
    // box_storage_del_refund_itxn = itxn.Payment(
    //     sender=Global.current_application_address,
    //     receiver=Txn.sender,
    //     amount=self.calc_box_storage_mbr() - min_txn_fee,
    //     fee=min_txn_fee,
    //     note="Account gets app box storage MBR (0.0169 ALGO) refunded.",
    // ).submit()
    itxn_submit
    itxn Receiver
    itxn Sender
    // smart_contracts/open_ballot/contract.py:358
    // box_storage_del_refund_itxn.sender == Global.current_application_address
    global CurrentApplicationAddress
    ==
    // smart_contracts/open_ballot/contract.py:357-359
    // assert (
    //     box_storage_del_refund_itxn.sender == Global.current_application_address
    // ), "box_storage_del_refund_itxn sender address must match application address."
    assert // box_storage_del_refund_itxn sender address must match application address.
    // smart_contracts/open_ballot/contract.py:362
    // box_storage_del_refund_itxn.receiver == Txn.sender
    txn Sender
    ==
    // smart_contracts/open_ballot/contract.py:361-363
    // assert (
    //     box_storage_del_refund_itxn.receiver == Txn.sender
    // ), "box_storage_del_refund_itxn reciever address must match transaction sender address."
    assert // box_storage_del_refund_itxn reciever address must match transaction sender address.
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.purge_box_storage(box_keys: bytes) -> void:
purge_box_storage:
    // smart_contracts/open_ballot/contract.py:366-368
    // # Enable application creator to execute box storage purge, this deletes any boxes not deleted by other accounts
    // @arc4.abimethod  # NOTE: Can also use arc4.StaticArray[arc4.Address, t.Literal[8]] to enforce strict size of 8
    // def purge_box_storage(self, box_keys: arc4.DynamicArray[arc4.Address]) -> None:
    proto 1 0
    pushbytes ""
    // smart_contracts/open_ballot/contract.py:371
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/open_ballot/contract.py:369-372
    // # Make necessary assertions to verify transaction requirements
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Unauthorized address! Only application creator can purge box storage."
    assert // Unauthorized address! Only application creator can purge box storage.
    // smart_contracts/open_ballot/contract.py:379
    // box_keys.length > 0 and box_keys.length < 9
    frame_dig -1
    intc_1 // 0
    extract_uint16
    dup
    bz purge_box_storage_bool_false@3
    frame_dig 1
    pushint 9 // 9
    <
    bz purge_box_storage_bool_false@3
    intc_0 // 1

purge_box_storage_bool_merge@4:
    // smart_contracts/open_ballot/contract.py:378-380
    // assert (
    //     box_keys.length > 0 and box_keys.length < 9
    // ), "The number of addresses represented by box keys array must be greater than 0 and lesser than 9."
    assert // The number of addresses represented by box keys array must be greater than 0 and lesser than 9.
    intc_1 // 0
    frame_bury 0

purge_box_storage_for_header@5:
    // smart_contracts/open_ballot/contract.py:382-383
    // # Iterate through the dynamic array of addresses representing the box key
    // for box_key in box_keys:
    frame_dig 0
    frame_dig 1
    <
    bz purge_box_storage_after_for@8
    frame_dig -1
    extract 2 0
    frame_dig 0
    dup
    cover 2
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: Index access is out of bounds
    // smart_contracts/open_ballot/contract.py:386
    // box_key.native in self.box_a_voter_data
    bytec_0 // 0x615f
    dig 1
    concat
    dup
    box_len
    bury 1
    // smart_contracts/open_ballot/contract.py:384-387
    // # Make necessary assertions to verify transaction requirements
    // assert (
    //     box_key.native in self.box_a_voter_data
    // ), "Account address represented in box key must be present in box a_."
    assert // Account address represented in box key must be present in box a_.
    // smart_contracts/open_ballot/contract.py:390
    // box_key.native != Global.creator_address
    global CreatorAddress
    uncover 2
    !=
    // smart_contracts/open_ballot/contract.py:389-391
    // assert (
    //     box_key.native != Global.creator_address
    // ), "Account address represented in box key must not match application creator address."
    assert // Account address represented in box key must not match application creator address.
    // smart_contracts/open_ballot/contract.py:393-395
    // del self.box_a_voter_data[
    //     box_key.native
    // ]  # Delete box key (address) from box storage
    box_del
    pop
    // smart_contracts/open_ballot/contract.py:396
    // self.total_purged_box_a_ += UInt64(
    intc_1 // 0
    bytec_1 // "total_purged_box_a_"
    app_global_get_ex
    assert // check self.total_purged_box_a_ exists
    // smart_contracts/open_ballot/contract.py:396-398
    // self.total_purged_box_a_ += UInt64(
    //     1
    // )  # Increment box 'a_' purged total amount
    intc_0 // 1
    +
    // smart_contracts/open_ballot/contract.py:396
    // self.total_purged_box_a_ += UInt64(
    bytec_1 // "total_purged_box_a_"
    // smart_contracts/open_ballot/contract.py:396-398
    // self.total_purged_box_a_ += UInt64(
    //     1
    // )  # Increment box 'a_' purged total amount
    swap
    app_global_put
    intc_0 // 1
    +
    frame_bury 0
    b purge_box_storage_for_header@5

purge_box_storage_after_for@8:
    retsub

purge_box_storage_bool_false@3:
    intc_1 // 0
    b purge_box_storage_bool_merge@4


// smart_contracts.open_ballot.contract.OpenBallot.terminate() -> void:
terminate:
    // smart_contracts/open_ballot/contract.py:401-403
    // # Allow application creator to delete the smart contract client, decrease their MBR balance + any remaining box MBR
    // @arc4.abimethod(create="disallow", allow_actions=["DeleteApplication"])
    // def terminate(self) -> None:
    proto 0 0
    intc_1 // 0
    dup
    // smart_contracts/open_ballot/contract.py:404-407
    // # Make necessary assertions to verify transaction requirements
    // assert TemplateVar[UInt64](
    //     "DELETABLE"
    // ), "Template variable 'DELETABLE' needs to be 'True' at deploy-time."
    intc 5 // TMPL_DELETABLE
    assert // Template variable 'DELETABLE' needs to be 'True' at deploy-time.
    // smart_contracts/open_ballot/contract.py:410
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/open_ballot/contract.py:409-411
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Unauthorized address! Only application creator can delete the smart contract."
    assert // Unauthorized address! Only application creator can delete the smart contract.
    // smart_contracts/open_ballot/contract.py:414
    // Global.creator_address in self.box_a_voter_data
    bytec_0 // 0x615f
    global CreatorAddress
    concat
    box_len
    bury 1
    // smart_contracts/open_ballot/contract.py:413-415
    // assert (
    //     Global.creator_address in self.box_a_voter_data
    // ), "Transaction sender address must be present in box a_."
    assert // Transaction sender address must be present in box a_.
    // smart_contracts/open_ballot/contract.py:421
    // del self.box_a_voter_data[
    bytec_0 // 0x615f
    // smart_contracts/open_ballot/contract.py:422
    // Global.creator_address
    global CreatorAddress
    // smart_contracts/open_ballot/contract.py:421-423
    // del self.box_a_voter_data[
    //     Global.creator_address
    // ]  # Delete box key (creator address) from box storage
    concat
    box_del
    pop
    // smart_contracts/open_ballot/contract.py:427
    // if self.total_purged_box_a_ > UInt64(0):
    intc_1 // 0
    bytec_1 // "total_purged_box_a_"
    app_global_get_ex
    assert // check self.total_purged_box_a_ exists
    bz terminate_else_body@3
    // smart_contracts/open_ballot/contract.py:428-440
    // # Execute inner transaction payment with purge refund and close remainder
    // del_app_refund_itxn = itxn.Payment(
    //     sender=Global.current_application_address,
    //     receiver=Global.creator_address,
    //     amount=(
    //         self.total_purged_box_a_ * self.calc_box_storage_mbr() - min_txn_fee
    //     ),
    //     fee=min_txn_fee,
    //     close_remainder_to=Global.creator_address,
    //     note=(
    //         "Closed remainder of app balance + purged box storage amount to Creator after deletion method."
    //     ),
    // ).submit()
    itxn_begin
    // smart_contracts/open_ballot/contract.py:430
    // sender=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/open_ballot/contract.py:431
    // receiver=Global.creator_address,
    global CreatorAddress
    // smart_contracts/open_ballot/contract.py:433
    // self.total_purged_box_a_ * self.calc_box_storage_mbr() - min_txn_fee
    intc_1 // 0
    bytec_1 // "total_purged_box_a_"
    app_global_get_ex
    assert // check self.total_purged_box_a_ exists
    // smart_contracts/open_ballot/contract.py:91-92
    // # Return single box fee
    // return base_fee.native + size_fee
    intc_2 // 16900
    // smart_contracts/open_ballot/contract.py:433
    // self.total_purged_box_a_ * self.calc_box_storage_mbr() - min_txn_fee
    *
    // smart_contracts/open_ballot/contract.py:425-426
    // # Define final closing app balance refund transaction
    // min_txn_fee = arc4.UInt16(1000).native  # Minimum acceptable fee for transaction
    intc_3 // 1000
    // smart_contracts/open_ballot/contract.py:433
    // self.total_purged_box_a_ * self.calc_box_storage_mbr() - min_txn_fee
    -
    // smart_contracts/open_ballot/contract.py:436
    // close_remainder_to=Global.creator_address,
    global CreatorAddress
    // smart_contracts/open_ballot/contract.py:438
    // "Closed remainder of app balance + purged box storage amount to Creator after deletion method."
    pushbytes "Closed remainder of app balance + purged box storage amount to Creator after deletion method."
    itxn_field Note
    itxn_field CloseRemainderTo
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/open_ballot/contract.py:428-429
    // # Execute inner transaction payment with purge refund and close remainder
    // del_app_refund_itxn = itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    // smart_contracts/open_ballot/contract.py:425-426
    // # Define final closing app balance refund transaction
    // min_txn_fee = arc4.UInt16(1000).native  # Minimum acceptable fee for transaction
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/open_ballot/contract.py:428-440
    // # Execute inner transaction payment with purge refund and close remainder
    // del_app_refund_itxn = itxn.Payment(
    //     sender=Global.current_application_address,
    //     receiver=Global.creator_address,
    //     amount=(
    //         self.total_purged_box_a_ * self.calc_box_storage_mbr() - min_txn_fee
    //     ),
    //     fee=min_txn_fee,
    //     close_remainder_to=Global.creator_address,
    //     note=(
    //         "Closed remainder of app balance + purged box storage amount to Creator after deletion method."
    //     ),
    // ).submit()
    itxn_submit
    itxn Sender
    itxn Receiver
    frame_bury 1
    itxn CloseRemainderTo
    frame_bury 0

terminate_after_if_else@5:
    // smart_contracts/open_ballot/contract.py:453
    // del_app_refund_itxn.sender == Global.current_application_address
    global CurrentApplicationAddress
    ==
    // smart_contracts/open_ballot/contract.py:452-454
    // assert (
    //     del_app_refund_itxn.sender == Global.current_application_address
    // ), "del_app_refund_itxn 'sender' address must match Application address."
    assert // del_app_refund_itxn 'sender' address must match Application address.
    // smart_contracts/open_ballot/contract.py:457
    // del_app_refund_itxn.receiver
    frame_dig 1
    global ZeroAddress
    !=
    // smart_contracts/open_ballot/contract.py:457-458
    // del_app_refund_itxn.receiver
    // and del_app_refund_itxn.close_remainder_to == Global.creator_address
    bz terminate_bool_false@8
    // smart_contracts/open_ballot/contract.py:458
    // and del_app_refund_itxn.close_remainder_to == Global.creator_address
    frame_dig 0
    global CreatorAddress
    ==
    // smart_contracts/open_ballot/contract.py:457-458
    // del_app_refund_itxn.receiver
    // and del_app_refund_itxn.close_remainder_to == Global.creator_address
    bz terminate_bool_false@8
    intc_0 // 1

terminate_bool_merge@9:
    // smart_contracts/open_ballot/contract.py:456-459
    // assert (
    //     del_app_refund_itxn.receiver
    //     and del_app_refund_itxn.close_remainder_to == Global.creator_address
    // ), "del_app_refund_itxn 'reciever' and 'close_remainder_to' address must match application Creator address."
    assert // del_app_refund_itxn 'reciever' and 'close_remainder_to' address must match application Creator address.
    retsub

terminate_bool_false@8:
    intc_1 // 0
    b terminate_bool_merge@9

terminate_else_body@3:
    // smart_contracts/open_ballot/contract.py:442-450
    // # Execute inner transaction that only closes app remainder balance to the creator
    // del_app_refund_itxn = itxn.Payment(
    //     sender=Global.current_application_address,
    //     receiver=Global.creator_address,
    //     amount=UInt64(0),  # Send zero amount
    //     fee=min_txn_fee,
    //     close_remainder_to=Global.creator_address,
    //     note="Closing remainder of app balance to Creator after deletion method.",
    // ).submit()
    itxn_begin
    // smart_contracts/open_ballot/contract.py:444
    // sender=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/open_ballot/contract.py:445
    // receiver=Global.creator_address,
    global CreatorAddress
    // smart_contracts/open_ballot/contract.py:448
    // close_remainder_to=Global.creator_address,
    dup
    // smart_contracts/open_ballot/contract.py:449
    // note="Closing remainder of app balance to Creator after deletion method.",
    pushbytes "Closing remainder of app balance to Creator after deletion method."
    itxn_field Note
    itxn_field CloseRemainderTo
    // smart_contracts/open_ballot/contract.py:446
    // amount=UInt64(0),  # Send zero amount
    intc_1 // 0
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/open_ballot/contract.py:442-443
    // # Execute inner transaction that only closes app remainder balance to the creator
    // del_app_refund_itxn = itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    // smart_contracts/open_ballot/contract.py:425-426
    // # Define final closing app balance refund transaction
    // min_txn_fee = arc4.UInt16(1000).native  # Minimum acceptable fee for transaction
    intc_3 // 1000
    itxn_field Fee
    // smart_contracts/open_ballot/contract.py:442-450
    // # Execute inner transaction that only closes app remainder balance to the creator
    // del_app_refund_itxn = itxn.Payment(
    //     sender=Global.current_application_address,
    //     receiver=Global.creator_address,
    //     amount=UInt64(0),  # Send zero amount
    //     fee=min_txn_fee,
    //     close_remainder_to=Global.creator_address,
    //     note="Closing remainder of app balance to Creator after deletion method.",
    // ).submit()
    itxn_submit
    itxn Sender
    itxn Receiver
    frame_bury 1
    itxn CloseRemainderTo
    frame_bury 0
    b terminate_after_if_else@5
