#pragma version 10

smart_contracts.open_ballot.contract.OpenBallot.approval_program:
    intcblock 1 0 116 TMPL_VERSION_UNIX TMPL_DELETABLE
    bytecblock 0x615f "poll_finalized" "choice1_total" "choice2_total" "choice3_total" "total_votes" 0x0000
    callsub __puya_arc4_router__
    return


// smart_contracts.open_ballot.contract.OpenBallot.__puya_arc4_router__() -> uint64:
__puya_arc4_router__:
    // smart_contracts/open_ballot/contract.py:24
    // class OpenBallot(ARC4Contract):
    proto 0 1
    txn NumAppArgs
    bz __puya_arc4_router___after_if_else@12
    pushbytess 0x5be219f0 0x81e1658f 0xe6bf4f23 0xf537b05b 0x0aae0803 0x761dd0fa 0x5ff16da4 // method "generate()void", method "get_version_unix()uint64", method "set_poll(byte[],byte[],byte[],byte[],uint64,uint64)void", method "fund_box_storage_mbr(pay)void", method "request_box(pay)void", method "submit_vote(uint8)void", method "terminate()void"
    txna ApplicationArgs 0
    match __puya_arc4_router___generate_route@2 __puya_arc4_router___get_version_unix_route@3 __puya_arc4_router___set_poll_route@4 __puya_arc4_router___fund_box_storage_mbr_route@5 __puya_arc4_router___request_box_route@6 __puya_arc4_router___submit_vote_route@7 __puya_arc4_router___terminate_route@8
    intc_1 // 0
    retsub

__puya_arc4_router___generate_route@2:
    // smart_contracts/open_ballot/contract.py:102-103
    // # Creates the smart contract client
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub generate
    intc_0 // 1
    retsub

__puya_arc4_router___get_version_unix_route@3:
    // smart_contracts/open_ballot/contract.py:127-128
    // # Retrieves the version of the smart contract as a Unix timestamp
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_version_unix
    itob
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    retsub

__puya_arc4_router___set_poll_route@4:
    // smart_contracts/open_ballot/contract.py:132-133
    // # Allows the creator to set up poll data values including title, choices, and dates
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/open_ballot/contract.py:24
    // class OpenBallot(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    extract 2 0
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    // smart_contracts/open_ballot/contract.py:132-133
    // # Allows the creator to set up poll data values including title, choices, and dates
    // @arc4.abimethod()
    callsub set_poll
    intc_0 // 1
    retsub

__puya_arc4_router___fund_box_storage_mbr_route@5:
    // smart_contracts/open_ballot/contract.py:189-190
    // # Request the use of box storage by making a payment to the App address that covers the MBR cost per box
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/open_ballot/contract.py:24
    // class OpenBallot(ARC4Contract):
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/open_ballot/contract.py:189-190
    // # Request the use of box storage by making a payment to the App address that covers the MBR cost per box
    // @arc4.abimethod()
    callsub fund_box_storage_mbr
    intc_0 // 1
    retsub

__puya_arc4_router___request_box_route@6:
    // smart_contracts/open_ballot/contract.py:221-222
    // # Request the use of box(es) by making a payment to the App address that covers the fee
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/open_ballot/contract.py:24
    // class OpenBallot(ARC4Contract):
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/open_ballot/contract.py:221-222
    // # Request the use of box(es) by making a payment to the App address that covers the fee
    // @arc4.abimethod()
    callsub request_box
    intc_0 // 1
    retsub

__puya_arc4_router___submit_vote_route@7:
    // smart_contracts/open_ballot/contract.py:284-285
    // # Allows an opted-in account to submit a vote during the active voting period
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/open_ballot/contract.py:24
    // class OpenBallot(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/open_ballot/contract.py:284-285
    // # Allows an opted-in account to submit a vote during the active voting period
    // @arc4.abimethod()
    callsub submit_vote
    intc_0 // 1
    retsub

__puya_arc4_router___terminate_route@8:
    // smart_contracts/open_ballot/contract.py:337-338
    // # Allows the creator to delete the smart contract client
    // @arc4.abimethod(create="disallow", allow_actions=["DeleteApplication"])
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub terminate
    intc_0 // 1
    retsub

__puya_arc4_router___after_if_else@12:
    // smart_contracts/open_ballot/contract.py:24
    // class OpenBallot(ARC4Contract):
    intc_1 // 0
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.generate() -> void:
generate:
    // smart_contracts/open_ballot/contract.py:102-104
    // # Creates the smart contract client
    // @arc4.abimethod(create="require")
    // def generate(self) -> None:
    proto 0 0
    // smart_contracts/open_ballot/contract.py:107
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/open_ballot/contract.py:105-108
    // # Make necessary assertions to verify transaction requirements
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Transaction sender must match creator address."
    assert // Transaction sender must match creator address.
    // smart_contracts/open_ballot/contract.py:110
    // assert Global.creator_address.balance >= (
    global CreatorAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/open_ballot/contract.py:111
    // Global.min_balance
    global MinBalance
    // smart_contracts/open_ballot/contract.py:113
    // num_bytes=UInt64(4), num_uint=UInt64(8)
    pushints 4 8 // 4, 8
    // smart_contracts/open_ballot/contract.py:112-114
    // + self.calc_schema_mbr(
    //     num_bytes=UInt64(4), num_uint=UInt64(8)
    // )  # Global schema MBR: 0.528 ALGO
    callsub calc_schema_mbr
    // smart_contracts/open_ballot/contract.py:111-114
    // Global.min_balance
    // + self.calc_schema_mbr(
    //     num_bytes=UInt64(4), num_uint=UInt64(8)
    // )  # Global schema MBR: 0.528 ALGO
    +
    // smart_contracts/open_ballot/contract.py:110-114
    // assert Global.creator_address.balance >= (
    //     Global.min_balance
    //     + self.calc_schema_mbr(
    //         num_bytes=UInt64(4), num_uint=UInt64(8)
    //     )  # Global schema MBR: 0.528 ALGO
    >=
    // smart_contracts/open_ballot/contract.py:110-115
    // assert Global.creator_address.balance >= (
    //     Global.min_balance
    //     + self.calc_schema_mbr(
    //         num_bytes=UInt64(4), num_uint=UInt64(8)
    //     )  # Global schema MBR: 0.528 ALGO
    // ), "Creator address balance must be equal or greater than Global.min_balance + Global schema MBR amount."
    assert // Creator address balance must be equal or greater than Global.min_balance + Global schema MBR amount.
    // smart_contracts/open_ballot/contract.py:117-118
    // # Global storage variable value assignments
    // self.poll_finalized = UInt64(0)
    bytec_1 // "poll_finalized"
    intc_1 // 0
    app_global_put
    // smart_contracts/open_ballot/contract.py:120
    // self.total_accounts_opted_in = UInt64(0)
    pushbytes "total_accounts_opted_in"
    intc_1 // 0
    app_global_put
    // smart_contracts/open_ballot/contract.py:122
    // self.choice1_total = UInt64(0)
    bytec_2 // "choice1_total"
    intc_1 // 0
    app_global_put
    // smart_contracts/open_ballot/contract.py:123
    // self.choice2_total = UInt64(0)
    bytec_3 // "choice2_total"
    intc_1 // 0
    app_global_put
    // smart_contracts/open_ballot/contract.py:124
    // self.choice3_total = UInt64(0)
    bytec 4 // "choice3_total"
    intc_1 // 0
    app_global_put
    // smart_contracts/open_ballot/contract.py:125
    // self.total_votes = UInt64(0)
    bytec 5 // "total_votes"
    intc_1 // 0
    app_global_put
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.calc_schema_mbr(num_bytes: uint64, num_uint: uint64) -> uint64:
calc_schema_mbr:
    // smart_contracts/open_ballot/contract.py:86-88
    // # Calculates the Global and Local schema minimum balance requirement total cost for the smart contract
    // @subroutine
    // def calc_schema_mbr(self, num_bytes: UInt64, num_uint: UInt64) -> UInt64:
    proto 2 1
    // smart_contracts/open_ballot/contract.py:92
    // byte_fee = UInt64(50_000)  # Byte slice fee for key-value pair (25_000 + 25_000)
    pushint 50000 // 50000
    // smart_contracts/open_ballot/contract.py:95-96
    // # Multiply respective fee cost with the number of key-value pairs in each schema to get total fee amount
    // total_byte_fee = byte_fee * num_bytes
    frame_dig -2
    *
    // smart_contracts/open_ballot/contract.py:93
    // uint_fee = UInt64(28_500)  # UInt64 fee for key-value pair (25_000 + 3_500)
    pushint 28500 // 28500
    // smart_contracts/open_ballot/contract.py:97
    // total_uint_fee = uint_fee * num_uint
    frame_dig -1
    *
    // smart_contracts/open_ballot/contract.py:90-91
    // # Schema individual fees
    // base_fee = UInt64(100_000)  # Base fee (100_000 * (1 + ExtraProgramPages))
    pushint 100000 // 100000
    // smart_contracts/open_ballot/contract.py:99-100
    // # Return the minimum balance requirement total cost
    // return base_fee + total_byte_fee + total_uint_fee
    uncover 2
    +
    +
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.get_version_unix() -> uint64:
get_version_unix:
    // smart_contracts/open_ballot/contract.py:127-129
    // # Retrieves the version of the smart contract as a Unix timestamp
    // @arc4.abimethod()
    // def get_version_unix(self) -> UInt64:
    proto 0 1
    // smart_contracts/open_ballot/contract.py:130
    // return TemplateVar[UInt64]("VERSION_UNIX")
    intc_3 // TMPL_VERSION_UNIX
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.set_poll(title: bytes, choice1: bytes, choice2: bytes, choice3: bytes, start_date_unix: uint64, end_date_unix: uint64) -> void:
set_poll:
    // smart_contracts/open_ballot/contract.py:132-142
    // # Allows the creator to set up poll data values including title, choices, and dates
    // @arc4.abimethod()
    // def set_poll(
    //     self,
    //     title: Bytes,
    //     choice1: Bytes,
    //     choice2: Bytes,
    //     choice3: Bytes,
    //     start_date_unix: UInt64,
    //     end_date_unix: UInt64,
    // ) -> None:
    proto 6 0
    // smart_contracts/open_ballot/contract.py:143-144
    // # Make necessary assertions to verify transaction requirements
    // assert Txn.sender == Global.creator_address, "Only App creator can set up poll."
    txn Sender
    global CreatorAddress
    ==
    assert // Only App creator can set up poll.
    // smart_contracts/open_ballot/contract.py:146
    // assert title.length <= UInt64(
    frame_dig -6
    len
    // smart_contracts/open_ballot/contract.py:146-148
    // assert title.length <= UInt64(
    //     118
    // ), "Poll title size can not exceed 118 bytes of data per key-value."
    pushint 118 // 118
    <=
    assert // Poll title size can not exceed 118 bytes of data per key-value.
    // smart_contracts/open_ballot/contract.py:151
    // choice1.length <= UInt64(116)
    frame_dig -5
    len
    intc_2 // 116
    <=
    // smart_contracts/open_ballot/contract.py:151-153
    // choice1.length <= UInt64(116)
    // and choice2.length <= UInt64(116)
    // and choice3.length <= UInt64(116)
    bz set_poll_bool_false@4
    // smart_contracts/open_ballot/contract.py:152
    // and choice2.length <= UInt64(116)
    frame_dig -4
    len
    intc_2 // 116
    <=
    // smart_contracts/open_ballot/contract.py:151-153
    // choice1.length <= UInt64(116)
    // and choice2.length <= UInt64(116)
    // and choice3.length <= UInt64(116)
    bz set_poll_bool_false@4
    // smart_contracts/open_ballot/contract.py:153
    // and choice3.length <= UInt64(116)
    frame_dig -3
    len
    intc_2 // 116
    <=
    // smart_contracts/open_ballot/contract.py:151-153
    // choice1.length <= UInt64(116)
    // and choice2.length <= UInt64(116)
    // and choice3.length <= UInt64(116)
    bz set_poll_bool_false@4
    intc_0 // 1
    b set_poll_bool_merge@5

set_poll_bool_false@4:
    intc_1 // 0

set_poll_bool_merge@5:
    // smart_contracts/open_ballot/contract.py:150-154
    // assert (
    //     choice1.length <= UInt64(116)
    //     and choice2.length <= UInt64(116)
    //     and choice3.length <= UInt64(116)
    // ), "Poll choice size cannot exceed 116 bytes of data per key-value."
    assert // Poll choice size cannot exceed 116 bytes of data per key-value.
    // smart_contracts/open_ballot/contract.py:165
    // start_date_unix < end_date_unix
    frame_dig -2
    frame_dig -1
    <
    // smart_contracts/open_ballot/contract.py:164-166
    // assert (
    //     start_date_unix < end_date_unix
    // ), "Start date must be earlier than end date."
    assert // Start date must be earlier than end date.
    // smart_contracts/open_ballot/contract.py:168-170
    // assert end_date_unix >= start_date_unix + UInt64(
    //     3 * 24 * 60 * 60
    // ), "End date must be at least 3 days later than the start date."
    frame_dig -2
    pushint 259200 // 259200
    +
    frame_dig -1
    <=
    assert // End date must be at least 3 days later than the start date.
    // smart_contracts/open_ballot/contract.py:172
    // assert end_date_unix - start_date_unix <= UInt64(
    frame_dig -1
    frame_dig -2
    -
    // smart_contracts/open_ballot/contract.py:172-174
    // assert end_date_unix - start_date_unix <= UInt64(
    //     14 * 24 * 60 * 60
    // ), "Voting period can not exceed 14 days."
    pushint 1209600 // 1209600
    <=
    assert // Voting period can not exceed 14 days.
    // smart_contracts/open_ballot/contract.py:176
    // assert self.poll_finalized == UInt64(0), "Poll can only be setup once."
    intc_1 // 0
    bytec_1 // "poll_finalized"
    app_global_get_ex
    assert // check self.poll_finalized exists
    !
    assert // Poll can only be setup once.
    // smart_contracts/open_ballot/contract.py:178-179
    // # Update global state keys with new values
    // self.poll_title = title
    pushbytes "poll_title"
    frame_dig -6
    app_global_put
    // smart_contracts/open_ballot/contract.py:180
    // self.poll_choice1 = choice1
    pushbytes "poll_choice1"
    frame_dig -5
    app_global_put
    // smart_contracts/open_ballot/contract.py:181
    // self.poll_choice2 = choice2
    pushbytes "poll_choice2"
    frame_dig -4
    app_global_put
    // smart_contracts/open_ballot/contract.py:182
    // self.poll_choice3 = choice3
    pushbytes "poll_choice3"
    frame_dig -3
    app_global_put
    // smart_contracts/open_ballot/contract.py:183
    // self.poll_start_date_unix = start_date_unix
    pushbytes "poll_start_date_unix"
    frame_dig -2
    app_global_put
    // smart_contracts/open_ballot/contract.py:184
    // self.poll_end_date_unix = end_date_unix
    pushbytes "poll_end_date_unix"
    frame_dig -1
    app_global_put
    // smart_contracts/open_ballot/contract.py:186-187
    // # Finalize poll (ensures poll can only be set once)
    // self.poll_finalized = UInt64(1)
    bytec_1 // "poll_finalized"
    intc_0 // 1
    app_global_put
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.fund_box_storage_mbr(mbr_pay: uint64) -> void:
fund_box_storage_mbr:
    // smart_contracts/open_ballot/contract.py:189-191
    // # Request the use of box storage by making a payment to the App address that covers the MBR cost per box
    // @arc4.abimethod()
    // def fund_box_storage_mbr(self, mbr_pay: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/open_ballot/contract.py:194
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/open_ballot/contract.py:192-195
    // # Make necessary assertions to verify transaction requirements
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Transaction sender must match creator address."
    assert // Transaction sender must match creator address.
    // smart_contracts/open_ballot/contract.py:198
    // mbr_pay.sender == Global.creator_address
    frame_dig -1
    gtxns Sender
    global CreatorAddress
    ==
    // smart_contracts/open_ballot/contract.py:197-199
    // assert (
    //     mbr_pay.sender == Global.creator_address
    // ), "MBR payment sender address must match the App creator address."
    assert // MBR payment sender address must match the App creator address.
    // smart_contracts/open_ballot/contract.py:202
    // mbr_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/open_ballot/contract.py:201-203
    // assert (
    //     mbr_pay.receiver == Global.current_application_address
    // ), "MBR payment reciever address must match the App address."
    assert // MBR payment reciever address must match the App address.
    // smart_contracts/open_ballot/contract.py:206
    // mbr_pay.amount
    frame_dig -1
    gtxns Amount
    // smart_contracts/open_ballot/contract.py:207
    // >= self.calc_box_storage_mbr()  # Box Storage MBR: 0.0169 ALGO
    callsub calc_box_storage_mbr
    // smart_contracts/open_ballot/contract.py:206-207
    // mbr_pay.amount
    // >= self.calc_box_storage_mbr()  # Box Storage MBR: 0.0169 ALGO
    >=
    // smart_contracts/open_ballot/contract.py:205-208
    // assert (
    //     mbr_pay.amount
    //     >= self.calc_box_storage_mbr()  # Box Storage MBR: 0.0169 ALGO
    // ), "MBR payment must meet the minimum requirement amount."
    assert // MBR payment must meet the minimum requirement amount.
    // smart_contracts/open_ballot/contract.py:210
    // assert Global.current_application_address.balance >= (
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/open_ballot/contract.py:211
    // Global.min_balance + self.calc_box_storage_mbr()
    global MinBalance
    callsub calc_box_storage_mbr
    +
    // smart_contracts/open_ballot/contract.py:210-211
    // assert Global.current_application_address.balance >= (
    //     Global.min_balance + self.calc_box_storage_mbr()
    >=
    // smart_contracts/open_ballot/contract.py:210-212
    // assert Global.current_application_address.balance >= (
    //     Global.min_balance + self.calc_box_storage_mbr()
    // ), "App address balance must be equal or greater than Global.min_balance + Box Storage MBR amount."
    assert // App address balance must be equal or greater than Global.min_balance + Box Storage MBR amount.
    // smart_contracts/open_ballot/contract.py:214-216
    // # Check if voter data box doesn't already exist, if not (False) then create new one
    // # if not self.box_a_voter_data.maybe(Txn.sender)[1]: <- This works too if copy() used
    // if Global.creator_address not in self.box_a_voter_data:
    bytec_0 // 0x615f
    global CreatorAddress
    concat
    box_len
    bury 1
    bnz fund_box_storage_mbr_after_if_else@2
    // smart_contracts/open_ballot/contract.py:217
    // self.box_a_voter_data[Global.creator_address] = VoterData(
    bytec_0 // 0x615f
    global CreatorAddress
    concat
    // smart_contracts/open_ballot/contract.py:217-219
    // self.box_a_voter_data[Global.creator_address] = VoterData(
    //     arc4.UInt8(0), arc4.UInt8(0)
    // )
    bytec 6 // 0x0000
    box_put

fund_box_storage_mbr_after_if_else@2:
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.calc_box_storage_mbr() -> uint64:
calc_box_storage_mbr:
    // smart_contracts/open_ballot/contract.py:74-76
    // # Calculates the Box storage minimum balance requirement total cost for the smart contract
    // @subroutine
    // def calc_box_storage_mbr(self) -> UInt64:
    proto 0 1
    // smart_contracts/open_ballot/contract.py:80
    // arc4.UInt8(34), arc4.UInt8(2)
    pushbytess 0x22 0x02 // 0x22, 0x02
    // smart_contracts/open_ballot/contract.py:78-81
    // # Calculate Box A fee
    // box_a = self.calc_single_box_fee(
    //     arc4.UInt8(34), arc4.UInt8(2)
    // )  # fee: 0.0169 ALGO
    callsub calc_single_box_fee
    // smart_contracts/open_ballot/contract.py:83-84
    // # Return the minimum balance requirement total cost
    // return box_a
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.calc_single_box_fee(key_size: bytes, value_size: bytes) -> uint64:
calc_single_box_fee:
    // smart_contracts/open_ballot/contract.py:59-63
    // # Calculates box fee for single unit
    // @subroutine
    // def calc_single_box_fee(
    //     self, key_size: arc4.UInt8, value_size: arc4.UInt8
    // ) -> UInt64:
    proto 2 1
    // smart_contracts/open_ballot/contract.py:68
    // key_size.native + value_size.native
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    +
    // smart_contracts/open_ballot/contract.py:67
    // size_fee = arc4.UInt16(400).native * (
    pushint 400 // 400
    // smart_contracts/open_ballot/contract.py:67-69
    // size_fee = arc4.UInt16(400).native * (
    //     key_size.native + value_size.native
    // )  # Size fee (400 per byte * (len(key)+len(value)))
    *
    // smart_contracts/open_ballot/contract.py:71-72
    // # Return single box fee
    // return base_fee.native + size_fee
    pushint 2500 // 2500
    +
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.request_box(box_pay: uint64) -> void:
request_box:
    // smart_contracts/open_ballot/contract.py:221-223
    // # Request the use of box(es) by making a payment to the App address that covers the fee
    // @arc4.abimethod()
    // def request_box(self, box_pay: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/open_ballot/contract.py:226
    // Txn.sender not in self.box_a_voter_data
    bytec_0 // 0x615f
    txn Sender
    concat
    box_len
    bury 1
    !
    // smart_contracts/open_ballot/contract.py:224-227
    // # Make necessary assertions to verify transaction requirements
    // assert (
    //     Txn.sender not in self.box_a_voter_data
    // ), "Transaction sender must match creator address."
    assert // Transaction sender must match creator address.
    // smart_contracts/open_ballot/contract.py:230
    // box_pay.sender not in self.box_a_voter_data
    frame_dig -1
    gtxns Sender
    bytec_0 // 0x615f
    swap
    concat
    box_len
    bury 1
    !
    // smart_contracts/open_ballot/contract.py:229-231
    // assert (
    //     box_pay.sender not in self.box_a_voter_data
    // ), "Box payment sender address must match the App creator address."
    assert // Box payment sender address must match the App creator address.
    // smart_contracts/open_ballot/contract.py:234
    // box_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/open_ballot/contract.py:233-235
    // assert (
    //     box_pay.receiver == Global.current_application_address
    // ), "MBR payment reciever address must match the App address."
    assert // MBR payment reciever address must match the App address.
    // smart_contracts/open_ballot/contract.py:238
    // box_pay.amount
    frame_dig -1
    gtxns Amount
    // smart_contracts/open_ballot/contract.py:239
    // >= self.calc_box_storage_mbr()  # Box Storage MBR: 0.0169 ALGO
    callsub calc_box_storage_mbr
    // smart_contracts/open_ballot/contract.py:238-239
    // box_pay.amount
    // >= self.calc_box_storage_mbr()  # Box Storage MBR: 0.0169 ALGO
    >=
    // smart_contracts/open_ballot/contract.py:237-240
    // assert (
    //     box_pay.amount
    //     >= self.calc_box_storage_mbr()  # Box Storage MBR: 0.0169 ALGO
    // ), "MBR payment must meet the minimum requirement amount."
    assert // MBR payment must meet the minimum requirement amount.
    // smart_contracts/open_ballot/contract.py:242-244
    // # Check if voter data box doesn't already exist, if not (False) then create new one
    // # if not self.box_a_voter_data.maybe(Txn.sender)[1]: <- This works too if copy() used
    // if Txn.sender not in self.box_a_voter_data:
    bytec_0 // 0x615f
    txn Sender
    concat
    box_len
    bury 1
    bnz request_box_after_if_else@2
    // smart_contracts/open_ballot/contract.py:245
    // self.box_a_voter_data[Txn.sender] = VoterData(arc4.UInt8(0), arc4.UInt8(0))
    bytec_0 // 0x615f
    txn Sender
    concat
    bytec 6 // 0x0000
    box_put

request_box_after_if_else@2:
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.submit_vote(choice: bytes) -> void:
submit_vote:
    // smart_contracts/open_ballot/contract.py:284-286
    // # Allows an opted-in account to submit a vote during the active voting period
    // @arc4.abimethod()
    // def submit_vote(self, choice: arc4.UInt8) -> None:
    proto 1 0
    // smart_contracts/open_ballot/contract.py:290
    // Txn.sender in self.box_a_voter_data
    bytec_0 // 0x615f
    txn Sender
    concat
    box_len
    bury 1
    // smart_contracts/open_ballot/contract.py:289-291
    // assert (
    //     Txn.sender in self.box_a_voter_data
    // ), "Account not found as key in voter data box."
    assert // Account not found as key in voter data box.
    // smart_contracts/open_ballot/contract.py:294
    // self.box_a_voter_data[Txn.sender].voted,
    bytec_0 // 0x615f
    txn Sender
    concat
    box_get
    assert // check self.box_a_voter_data entry exists
    extract 0 1 // on error: Index access is out of bounds
    // smart_contracts/open_ballot/contract.py:296
    // ) == (arc4.UInt8(0), arc4.UInt8(0)), "Account already submitted a vote."
    pushbytes 0x00
    // smart_contracts/open_ballot/contract.py:293-296
    // assert (
    //     self.box_a_voter_data[Txn.sender].voted,
    //     self.box_a_voter_data[Txn.sender].choice,
    // ) == (arc4.UInt8(0), arc4.UInt8(0)), "Account already submitted a vote."
    b==
    // smart_contracts/open_ballot/contract.py:295
    // self.box_a_voter_data[Txn.sender].choice,
    bytec_0 // 0x615f
    txn Sender
    concat
    box_get
    assert // check self.box_a_voter_data entry exists
    extract 1 1 // on error: Index access is out of bounds
    // smart_contracts/open_ballot/contract.py:296
    // ) == (arc4.UInt8(0), arc4.UInt8(0)), "Account already submitted a vote."
    pushbytes 0x00
    // smart_contracts/open_ballot/contract.py:293-296
    // assert (
    //     self.box_a_voter_data[Txn.sender].voted,
    //     self.box_a_voter_data[Txn.sender].choice,
    // ) == (arc4.UInt8(0), arc4.UInt8(0)), "Account already submitted a vote."
    b==
    &&
    assert // Account already submitted a vote.
    // smart_contracts/open_ballot/contract.py:315
    // choice == arc4.UInt8(1)
    frame_dig -1
    pushbytes 0x01
    b==
    // smart_contracts/open_ballot/contract.py:315-317
    // choice == arc4.UInt8(1)
    // or choice == arc4.UInt8(2)
    // or choice == arc4.UInt8(3)
    bnz submit_vote_bool_true@3
    // smart_contracts/open_ballot/contract.py:316
    // or choice == arc4.UInt8(2)
    frame_dig -1
    pushbytes 0x02
    b==
    // smart_contracts/open_ballot/contract.py:315-317
    // choice == arc4.UInt8(1)
    // or choice == arc4.UInt8(2)
    // or choice == arc4.UInt8(3)
    bnz submit_vote_bool_true@3
    // smart_contracts/open_ballot/contract.py:317
    // or choice == arc4.UInt8(3)
    frame_dig -1
    pushbytes 0x03
    b==
    // smart_contracts/open_ballot/contract.py:315-317
    // choice == arc4.UInt8(1)
    // or choice == arc4.UInt8(2)
    // or choice == arc4.UInt8(3)
    bz submit_vote_bool_false@4

submit_vote_bool_true@3:
    intc_0 // 1
    b submit_vote_bool_merge@5

submit_vote_bool_false@4:
    intc_1 // 0

submit_vote_bool_merge@5:
    // smart_contracts/open_ballot/contract.py:314-318
    // assert (
    //     choice == arc4.UInt8(1)
    //     or choice == arc4.UInt8(2)
    //     or choice == arc4.UInt8(3)
    // ), "Invalid choice. Can only choose between choices 1, 2, 3."
    assert // Invalid choice. Can only choose between choices 1, 2, 3.
    // smart_contracts/open_ballot/contract.py:323-324
    // # Set account voter data
    // self.box_a_voter_data[Txn.sender] = VoterData(arc4.UInt8(1), choice)
    pushbytes 0x01
    frame_dig -1
    concat
    bytec_0 // 0x615f
    txn Sender
    concat
    swap
    box_put
    // smart_contracts/open_ballot/contract.py:326-327
    // # Update vote tally
    // if choice == UInt64(1):
    intc_0 // 1
    itob
    frame_dig -1
    b==
    bz submit_vote_else_body@7
    // smart_contracts/open_ballot/contract.py:328
    // self.choice1_total += UInt64(1)
    intc_1 // 0
    bytec_2 // "choice1_total"
    app_global_get_ex
    assert // check self.choice1_total exists
    intc_0 // 1
    +
    bytec_2 // "choice1_total"
    swap
    app_global_put
    b submit_vote_after_if_else@11

submit_vote_else_body@7:
    // smart_contracts/open_ballot/contract.py:329
    // elif choice == UInt64(2):
    pushint 2 // 2
    itob
    frame_dig -1
    b==
    bz submit_vote_else_body@9
    // smart_contracts/open_ballot/contract.py:330
    // self.choice2_total += UInt64(1)
    intc_1 // 0
    bytec_3 // "choice2_total"
    app_global_get_ex
    assert // check self.choice2_total exists
    intc_0 // 1
    +
    bytec_3 // "choice2_total"
    swap
    app_global_put
    b submit_vote_after_if_else@11

submit_vote_else_body@9:
    // smart_contracts/open_ballot/contract.py:332
    // self.choice3_total += UInt64(1)
    intc_1 // 0
    bytec 4 // "choice3_total"
    app_global_get_ex
    assert // check self.choice3_total exists
    intc_0 // 1
    +
    bytec 4 // "choice3_total"
    swap
    app_global_put

submit_vote_after_if_else@11:
    // smart_contracts/open_ballot/contract.py:334-335
    // # Increment count for total votes
    // self.total_votes += UInt64(1)
    intc_1 // 0
    bytec 5 // "total_votes"
    app_global_get_ex
    assert // check self.total_votes exists
    intc_0 // 1
    +
    bytec 5 // "total_votes"
    swap
    app_global_put
    retsub


// smart_contracts.open_ballot.contract.OpenBallot.terminate() -> void:
terminate:
    // smart_contracts/open_ballot/contract.py:337-339
    // # Allows the creator to delete the smart contract client
    // @arc4.abimethod(create="disallow", allow_actions=["DeleteApplication"])
    // def terminate(self) -> None:
    proto 0 0
    // smart_contracts/open_ballot/contract.py:342
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/open_ballot/contract.py:340-343
    // # Make necessary assertions to verify transaction requirements
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Only App creator can terminate the App."
    assert // Only App creator can terminate the App.
    // smart_contracts/open_ballot/contract.py:345-347
    // assert TemplateVar[UInt64](
    //     "DELETABLE"
    // ), "Template variable 'DELETABLE' needs to be set to 'true' at deploy-time."
    intc 4 // TMPL_DELETABLE
    assert // Template variable 'DELETABLE' needs to be set to 'true' at deploy-time.
    retsub
