# tests/open_ballot_test.py
import base64
import json
import time
from itertools import islice

import pytest
from algokit_utils import TransactionParameters
from algokit_utils.beta.account_manager import AddressAndSigner
from algokit_utils.beta.algorand_client import AlgorandClient, SuggestedParams
from algosdk.abi import Contract
from algosdk.atomic_transaction_composer import AtomicTransactionComposer
from algosdk.encoding import decode_address, encode_address
from algosdk.transaction import wait_for_confirmation

from smart_contracts.artifacts.open_ballot.open_ballot_client import OpenBallotClient

from .test_utils import read_box_data, setup_logger, setup_stxn

# Setup the logging.Logger
logger = setup_logger()


# Return an instance of the Algorand client from the default localnet config
@pytest.fixture(scope="session")
def algorand() -> AlgorandClient:
    return AlgorandClient.default_local_net()


# Create a dispenser account as AddreessAndSigner object that will fund other accounts
@pytest.fixture(scope="session")
def dispenser(algorand: AlgorandClient) -> AddressAndSigner:
    return algorand.account.dispenser()


# Generate a creator account for testing and fund it with some ALGO via the dispenser account
@pytest.fixture(scope="session")
def creator(algorand: AlgorandClient, dispenser: AddressAndSigner) -> AddressAndSigner:
    # Create a random Algorand account to represent the creator account
    creator = algorand.account.random()

    # Setup signed transaction that funds the creator account (dispenser is funding 50 ALGO to creator account address)
    fund_creator_acc = setup_stxn(
        algorand, dispenser, creator.address, 50_000_000
    )  # 100_000 = 0.1 ALGO

    # Send the signed transaction using the Algorand client
    algorand.send.payment(fund_creator_acc)

    # Return the creator account
    return creator


# Create a factory that can generate an arbitrary amount of randy accounts
@pytest.fixture(scope="session")
def randy_factory(algorand: AlgorandClient, dispenser: AddressAndSigner) -> dict:
    # Define the number of randy accounts that will be created and used for testing
    randy_accounts = 18

    # Create a list to store all the randy accounts that were randomly generated by the Algorand client
    randies = [algorand.account.random() for _ in range(randy_accounts)]

    # Create a list to store all the funding amounts (first randy gets 30_000_000, subsequent ones get 1_000_000 less)
    funding_amounts = [30_000_000 - i * 1_000_000 for i in range(randy_accounts)]

    # Take the matching indices of both lists and zip them into a tuple then iterate through a new list of these tuples
    for randy, amount in zip(randies, funding_amounts):
        dispenser_fund_randy_stxn = setup_stxn(
            algorand, dispenser, randy.address, amount
        )  # Prepare signed txn
        algorand.send.payment(
            dispenser_fund_randy_stxn
        )  # Send signed txn through the Algorand client
        logger.info(f"Funding {randy.address} with {amount} mAlgo")

    # Return a dict with all randy accounts (output: dict[str, AddressAndSigner])
    return {f"randy_{i+1}": randy for i, randy in enumerate(randies)}


# Create an app factory that can return several instances of the smart contract app client for testing
@pytest.fixture(scope="session")
def app_factory(
    algorand: AlgorandClient,
    creator: AddressAndSigner,
    randy_factory: dict[str, AddressAndSigner],
) -> dict:

    # Initialize new dict with creator client (named "app_client_1") as its first element
    app_clients = {
        "app_client_1": OpenBallotClient(
            algod_client=algorand.client.algod,
            sender=creator.address,
            signer=creator.signer,
            template_values={"DELETABLE": 1, "VERSION_UNIX": int(time.time())},
        )
    }

    # Use app_client_1 to send a transaction that generates a new smart contract using the 'Create' on-complete method
    creator_gen_app_client_1_txn = app_clients["app_client_1"].create_generate()

    # Verify transaction was confirmed by the network
    wait_for_confirmation(algorand.client.algod, creator_gen_app_client_1_txn.tx_id, 10)
    assert (
        creator_gen_app_client_1_txn.confirmed_round
    ), "creator_gen_app_client_1_txn transaction round needs confirmation."

    # Log
    logger.info(
        f"APP CLIENT 1 ID: {app_clients["app_client_1"].app_id}"
    )  #  Check client 1 app ID
    logger.info(  # Check client 1 Global State
        f"App Client 1 Global State: {vars(app_clients["app_client_1"].get_global_state())}"
    )

    # Attempt to deploy app_client_1 idempotently
    # app_clients["app_client_1"].deploy(
    #     version="alpha",
    #     create_args=create_args,
    #     delete_args=delete_args,
    #     on_update="append",  # Handle updates by appending new changes
    #     on_schema_break="fail",  # Fail if schema incompatibility occurs
    #     template_values={"DELETABLE": 1, "VERSION_UNIX": int(time.time())},,  # Deployment-time dynamic parameters
    #     allow_update=None,
    #     allow_delete=True,
    # )

    # Add additional app clients (using each randy account as the sender and signer for their own client)
    """OpenBallotClient can be created with an app_id to interact with an already existing application.
    Below, the 'Randy' accounts are creating their own instance of the smart contract client where they are the sender
    and signer, while passing 'Creator' account app_client_1 by its ID in order to interact with it."""
    for i, randy in enumerate(randy_factory.values(), start=2):
        app_clients[f"app_client_{i}"] = OpenBallotClient(
            algod_client=algorand.client.algod,
            sender=randy.address,
            signer=randy.signer,
            app_id=app_clients["app_client_1"].app_id,
            template_values={"DELETABLE": 1, "VERSION_UNIX": int(time.time())},
        )

    # Log
    logger.info(app_clients)

    # Return a dict with all app clients (output: dict[str, OpenBallotClient])
    return app_clients


# Return an ABI compliant Contract object made from the smart contract json file
@pytest.fixture(scope="session")
def sc() -> Contract:
    with open("./smart_contracts/artifacts/open_ballot/OpenBallot.arc32.json") as f:
        js = json.load(f)

    return Contract.from_json(json.dumps(js["contract"]))


# Update the suggested parameters for Algorand transactions.
@pytest.fixture()
def sp(algorand: AlgorandClient) -> SuggestedParams:
    sp = algorand.get_suggested_params()
    # sp.first = algorand.client.algod.status().get("last-round")
    # sp.last = sp.first + 1000
    return sp

# # Test case: Creator sets poll data (via default ["NoOp"] using the 'set_poll()' abimethod)
# def test_set_poll(
#     algorand: AlgorandClient,
#     app_factory: dict[str, OpenBallotClient],
# ) -> None:

#     # Poll data (title, choice1, choice2, choice3) is algopy.Bytes type and can be passed as byte literals
#     title = (
#         b"01234567890123456789012345678901234567890123456789012345678"
#         b"90123456789012345678901234567890123456789012345678901234567"
#     )  # 118 bytes in size

#     choice1 = (
#         b"0123456789012345678901234567890123456789012345678901234567"
#         b"8901234567890123456789012345678901234567890123456789012345"
#     )  # 116 bytes in size

#     choice2 = b"Twice"
#     choice3 = b""

#     # Define date format (second/minute/hour/day/month/year)
#     date_format = "%S/%M/%H/%d/%m/%Y"

#     # Set start date as str within acceptable params of the smart contract 'set_poll()' abimethod
#     start_date_str = "00/00/00/16/02/2025"  # 00:00:00 on February 16, 2005
#     start_date_unix = int(
#         time.mktime(time.strptime(start_date_str, date_format))
#     )  # Obtain start date unix via time module by passing the start date string and the date format

#     # Set enddate as str within acceptable params
#     end_date_str = "00/00/00/28/02/2025"  # 00:00:00 on February 28, 2025
#     end_date_unix = int(
#         time.mktime(time.strptime(end_date_str, date_format))
#     )  # Obtain end date unix via time module by passing the start date string and the date format

#     # Send transaction that calls the set_poll abimethod
#     set_poll_txn = app_factory["app_client_1"].set_poll(
#         title=title,
#         choice1=choice1,
#         choice2=choice2,
#         choice3=choice3,
#         start_date_unix=start_date_unix,
#         end_date_unix=end_date_unix,
#         transaction_parameters=TransactionParameters(suggested_params=sp),
#     )

#     # Verify transaction was confirmed by the network
#     wait_for_confirmation(algorand.client.algod, set_poll_txn.tx_id, 10)
#     assert (
#         set_poll_txn.confirmed_round
#     ), "set_poll_txn transaction round needs confirmation."

#     # Log
#     logger.info("SET POLL WAS HERE")


# # Test case: Creator funds smart contract address with enough to cover its minimum balance and creator box storage MBR
# def test_fund_app_mbr(
#     algorand: AlgorandClient,
#     app_factory: dict[str, OpenBallotClient],
#     creator: AddressAndSigner,
#     sp: SuggestedParams,
# ) -> None:

#     # Send transaction that calls the fund_app_mbr abimethod
#     fund_app_mbr_txn = app_factory["app_client_1"].fund_app_mbr(
#         mbr_pay=setup_stxn(
#             algorand, creator, app_factory["app_client_1"].app_address, 116_900
#         ),  # 100_000 (Global.min_balance) + 16_900 (Box fee)
#         transaction_parameters=TransactionParameters(
#             suggested_params=sp, boxes=[(0, b"a_" + decode_address(creator.address))]
#         ),
#     )

#     # Verify transaction was confirmed by the network
#     wait_for_confirmation(algorand.client.algod, fund_app_mbr_txn.tx_id, 10)
#     assert (
#         fund_app_mbr_txn.confirmed_round
#     ), "fund_app_mbr_txn transaction round needs confirmation."

#     # Read box storage data
#     read_box_data(
#         algorand,
#         app_factory["app_client_1"].app_id,
#         b"a_" + decode_address(creator.address),
#         logger,
#     )

#     # Log
#     logger.info(
#         f"APP CLIENT 1 ID: {app_factory["app_client_1"].app_id}"
#     )  #  Check client 1 app ID
#     logger.info(  # Check client 1 Global State
#         f"App Client 1 Global State: {vars(app_factory["app_client_1"].get_global_state())}"
#     )


# Test case: Add 'set_poll()' & 'fund_app_mbr' into an Atomic Transaction group and send it
def test_atxn_1(
    algorand: AlgorandClient,
    creator: AddressAndSigner,
    app_factory: dict[str, OpenBallotClient],
    sp: SuggestedParams,
    sc: Contract,
) -> None:

    # Construct new Atomic Transaction from the ATC object
    atxn = AtomicTransactionComposer()

    # Add 'set_poll()' method via add_method_call to the Atomic Transaction
    app_factory["app_client_1"].app_client.add_method_call(
        atxn,
        sc.get_method_by_name("set_poll"),
        abi_args={"title": b"MyTitle", "choice1": b"MyChoice1", "choice2": b"MyChoice2",
         "choice3": b"MyChoice3", "start_date_unix": 1739871607, "end_date_unix": 1740735607},
        app_id=app_factory["app_client_1"].app_id,
        parameters=TransactionParameters(
            suggested_params=sp,
            note="abi:set_poll",
        ),
    )

    # Add 'fund_app_mbr()' method via add_method_call to the Atomic Transaction
    app_factory["app_client_1"].app_client.add_method_call(
        atxn,
        sc.get_method_by_name("fund_app_mbr"),
        abi_args={"mbr_pay": setup_stxn(algorand, creator, app_factory[
        "app_client_1"].app_address, 116_900)},  # 100_000 (Global.min_balance) + 16_900 (Box fee)
        app_id=app_factory["app_client_1"].app_id,
        parameters=TransactionParameters(
            suggested_params=sp,
            boxes=[(0, b"a_" + decode_address(creator.address))],
            note="abi:fund_app_mbr"
        ),
    )

    # Execute the Atomic Transaction
    atxn_res = atxn.execute(algorand.client.algod, 2)
    logger.info(f" Atomic TXN IDS: f{atxn_res.tx_ids}")

    # Verify transactions were confirmed by the network
    for i in range(len(atxn_res.tx_ids)):
        wait_for_confirmation(algorand.client.algod, atxn_res.tx_ids[i], 10)

    assert (
        atxn_res.confirmed_round
    ), "atxn_res atomic transaction round needs confirmation."

    # Read box storage data
    read_box_data(
        algorand,
        app_factory["app_client_1"].app_id,
        b"a_" + decode_address(creator.address),
        logger,
    )

    # Log
    logger.info(
        f"APP CLIENT 1 ID: {app_factory["app_client_1"].app_id}"
    )  #  Check client 1 app ID
    logger.info(  # Check client 1 Global State
        f"App Client 1 Global State: {vars(app_factory["app_client_1"].get_global_state())}"
    )


# Test case: Multiple randy accounts request box storage access by paying box storage MBR
def test_request_box_storage(
    algorand: AlgorandClient,
    sp: SuggestedParams,
    app_factory: dict[str, OpenBallotClient],
    randy_factory: dict[str, AddressAndSigner],
) -> None:

    # Iterate over randy accounts and their app clients (excluding the creator's app client).
    for (randy_name, randy), (app_name, app_client) in zip(
        randy_factory.items(), list(app_factory.items())[1:]
    ):
        logger.info(
            f"Testing Request Box Storage abimethod for: {randy_name} using {app_name}"
        )

        # Send transaction that calls the request_box_storage abimethod
        req_box_txn = app_client.request_box_storage(
            mbr_pay=setup_stxn(
                algorand, randy, app_client.app_address, 16_900
            ),  # Box fee of 16,900 micro Algos
            transaction_parameters=TransactionParameters(
                suggested_params=sp,
                boxes=[
                    (0, b"a_" + decode_address(randy.address))
                ],  # List referencing App ID and Box name
                note="abi:request_box_storage",
            ),
        )

        # Verify transaction was confirmed by the network
        wait_for_confirmation(algorand.client.algod, req_box_txn.tx_id, 10)
        assert (
            req_box_txn.confirmed_round
        ), "req_box_txn transaction round needs confirmation."

        # Log
        read_box_data(
            algorand, app_client.app_id, b"a_" + decode_address(randy.address), logger
        )

    # Log
    app_boxes = algorand.client.algod.application_boxes(
        app_factory["app_client_1"].app_id
    )
    logger.info(f"app boxes array: {app_boxes["boxes"]}")
    logger.info(f"num of app boxes: {len(app_boxes["boxes"])}")

    logger.info(
        f"APP CLIENT 1 ID: {app_factory["app_client_1"].app_id}"
    )  #  Check client 1 app ID
    logger.info(  # Check client 1 Global State
        f"App Client 1 Global State: {vars(app_factory["app_client_1"].get_global_state())}"
    )


# Test case: Multiple randy accounts submit vote (via default ["NoOp"] using the 'submit_vote()' abimethod)
def test_submit_vote(
    algorand: AlgorandClient,
    sp: SuggestedParams,
    creator: AddressAndSigner,
    app_factory: dict[str, OpenBallotClient],
    randy_factory: dict[str, AddressAndSigner],
) -> None:

    # Define a helper inner function to submit a vote and verify the transaction
    def submit_and_verify_vote(
        app_client: OpenBallotClient, voter: AddressAndSigner, choice: int
    ):
        submit_vote_txn = app_client.submit_vote(
            choice=choice,
            transaction_parameters=TransactionParameters(
                suggested_params=sp,
                boxes=[(0, b"a_" + decode_address(voter.address))],
                note="abi:submit_vote"
            ),
        )
        wait_for_confirmation(algorand.client.algod, submit_vote_txn.tx_id, 10)
        assert (
            submit_vote_txn.confirmed_round
        ), f"{voter.address} submit_vote_txn transaction round needs confirmation."

    # Submit and verify votes for creator and randy accounts
    votes = [
        (app_factory["app_client_1"], creator, 3),
        (app_factory["app_client_2"], randy_factory["randy_1"], 2),
        (app_factory["app_client_3"], randy_factory["randy_2"], 1),
        (app_factory["app_client_4"], randy_factory["randy_3"], 3),
        (app_factory["app_client_5"], randy_factory["randy_4"], 1),
        (app_factory["app_client_6"], randy_factory["randy_5"], 1),
        (app_factory["app_client_7"], randy_factory["randy_6"], 1),
    ]

    for app_client, voter, choice in votes:
        submit_and_verify_vote(app_client, voter, choice)

    # Read box data for creator and all randies
    logger.info(f"Reading Box Storage values for {app_factory['app_client_1']}")
    read_box_data(
        algorand,
        app_factory["app_client_1"].app_id,
        b"a_" + decode_address(creator.address),
        logger,
    )
    for randy in randy_factory.values():
        read_box_data(
            algorand,
            app_factory["app_client_1"].app_id,
            b"a_" + decode_address(randy.address),
            logger,
        )

    # Log Global State
    logger.info(
        f"Global State attributes: {vars(app_factory['app_client_1'].get_global_state())}"
    )


# # Test case: Multiple randy accounts each delete their box storage each and get their paid MBR refunded
# def test_delete_box_storage(
#     algorand: AlgorandClient,
#     sp: SuggestedParams,
#     app_factory: dict[str, OpenBallotClient],
#     randy_factory: dict[str, AddressAndSigner],
# ) -> None:

#     # Iterate over randy accounts and their app clients (excluding the creator's app client).
#     for (randy_name, randy), (app_name, app_client) in zip(
#         # randy_factory.items(),
#         # list(app_factory.items())[1:],
#         list(randy_factory.items())[:-5], list(app_factory.items())[1:-5]):
#         logger.info(
#             f"Testing Delete Box Storage abimethod for: {randy_name} using {app_name}"
#         )

#         # Send transaction that calls the delete_box_storage abimethod
#         del_box_txn = app_client.delete_box_storage(
#             transaction_parameters=TransactionParameters(
#                 suggested_params=sp,
#                 boxes=[
#                     (0, b"a_" + decode_address(randy.address))
#                 ],  # List referencing App ID and Box name
#             ),  note = "abi:delete_box_storage",
#         )

#         # Verify transaction was confirmed by the network
#         wait_for_confirmation(algorand.client.algod, del_box_txn.tx_id, 10)
#         assert (
#             del_box_txn.confirmed_round
#         ), "del_box_txn transaction round needs confirmation."

#     # Log
#     app_boxes = algorand.client.algod.application_boxes(
#         app_factory["app_client_1"].app_id
#     )
#     logger.info(f"app boxes array: {app_boxes["boxes"]}")
#     logger.info(f"num of app boxes: {len(app_boxes["boxes"])}")

#     logger.info(
#         f"APP CLIENT 1 ID: {app_factory["app_client_1"].app_id}"
#     )  #  Check client 1 app ID
#     logger.info(  # Check client 1 Global State
#         f"App Client 1 Global State: {vars(app_factory["app_client_1"].get_global_state())}"
#     )


# Test case: Add 'purge_box_storage()' into Atomic Transaction groups and send them
def test_purge_box_stroage_atxns(
    algorand: AlgorandClient,
    creator: AddressAndSigner,
    app_factory: dict[str, OpenBallotClient],
    sp: SuggestedParams,
    sc: Contract,
) -> None:

    # Get an array of all boxes in application with given ID
    app_boxes = algorand.client.algod.application_boxes(
        app_factory["app_client_1"].app_id
    )

    # Iterate through all boxes in application and extract the address value from box name field
    box_addresses = []  # Define a list to store extracted addresses
    for box in app_boxes["boxes"]:
        box_key = base64.b64decode(box["name"])  # Decode the base64 encoded box name value to get box key
        address = encode_address(box_key[-32:])  # Last 32 bytes of box key value is address (rest is key prefix)

        # If address from box key matches creator address, do NOT append it
        if address != creator.address:
            box_addresses.append(address)

    # Define list that will store other lists, each representing a batch of box keys in byte format
    bk_batches = [
        [
            # This represents a batch list // Output: [addr1, addr2, addr3, addr4, addr5, addr6, addr7, addr8]
            decode_address(address)  # Decode the address
            for address in islice(box_addresses, i, i + 8)  # Slice first 8 incidies of box addresses
        ]
        # Iterate through box addresses indicies in steps of 8
        for i in range(0, len(box_addresses), 8)  # Output: 0, 8, 16,
    ]

    # Create a new ATC object for every two batches of box keys and store it in a dict
    atxn_factory = {f"atxn_{i + 1}": AtomicTransactionComposer() for i in range((len(bk_batches) + 1) // 2)}
    batch_counter = 0  # Initialize batch count

    # Loop until no more batches of box keys in bk_batches
    while bk_batches:
        # Pop first element of bk_batches (list[bytes]), this represents current batch of box keys
        bk_batch = bk_batches.pop(0)

        # Define atxn ID for the key of the app_factory dict in order to shift to new AtomicTransactionComposer() object
        atxn_id = (batch_counter // 2) + 1  # Every two batches, atxn_id increases by 1

        logger.info(f"bk_batch: {bk_batch}")
        logger.info(f"atxn_id: {atxn_id}")

        # Add method call to the atxn in app_factory under the key specific tied to atxn_id
        app_factory["app_client_1"].app_client.add_method_call(
            atxn_factory[f"atxn_{atxn_id}"],  # Access atxn under app_factory key
            sc.get_method_by_name("purge_box_storage"), # Get (ABI)Method by name
            abi_args={"box_keys": bk_batch},  # Pass current individual batch of box keys as arg
            app_id=app_factory["app_client_1"].app_id,  # Reference client by App ID
            parameters=TransactionParameters(
                suggested_params=sp,  # Pass fresh suggested params
                boxes=[(0, b"a_" + box_key) for box_key in bk_batch],  # Ref each box name in batch
                note="abi:purge_box_storage",
            ),
        )

        # Execute Atomic transactions
        # If batch counter is odd or bk_batch is empty (meaning last array is being proccessed)
        if batch_counter % 2 == 1 or len(bk_batches) == 0:
            logger.info(f"Executing atxn {atxn_id}")
            atxn_res = atxn_factory[f"atxn_{atxn_id}"].execute(algorand.client.algod, 2)

            # Wait for confirmations (confirm for every txn id in atxn)
            for tx_id in atxn_res.tx_ids:
                wait_for_confirmation(algorand.client.algod, tx_id, 10)

            # Ensure the atxn response atomic transaction was confirmed by network
            assert atxn_res.confirmed_round, "atxn_res atomic transaction round needs confirmation."

        # Increment batch counter by 1 (signals next batch is being processed)
        batch_counter += 1

    # Log
    logger.info(
        f"APP CLIENT 1 ID: {app_factory['app_client_1'].app_id}"
    )  #  Check client 1 app ID
    logger.info(  # Check client 1 Global State
        f"App Client 1 Global State: {vars(app_factory['app_client_1'].get_global_state())}"
    )

    app_boxes = algorand.client.algod.application_boxes(
        app_factory["app_client_1"].app_id
    )

    # Log
    logger.info(f"app boxes array after purge: {app_boxes["boxes"]}")
    logger.info(f"num of app boxes after purge: {len(app_boxes["boxes"])}")


# Test case: Creator deletes app client (via ["DeleteApplication"] 'terminate' abimethod & gets purged box MBR if any)
def test_delete_app(
    algorand: AlgorandClient,
    sp: SuggestedParams,
    app_factory: dict[str, OpenBallotClient],
    creator: AddressAndSigner,
) -> None:

    # Get creator and app account balances before the delete method is called
    creator_before_balance = algorand.account.get_information(creator.address)["amount"]
    app_before_balance = algorand.account.get_information(
        app_factory["app_client_1"].app_address
    )["amount"]

    # Log
    logger.info(f"Creator account balance before deletion: {creator_before_balance}")
    logger.info(f"App account balance before deletion: {app_before_balance}")

    # Use App client to send a transaction that executes the 'terminate' delete application abimethod
    delete_app_client_1_txn = app_factory["app_client_1"].delete_terminate(
        transaction_parameters=TransactionParameters(
            suggested_params=sp, boxes=[(0, b"a_" + decode_address(creator.address))]
        )
    )

    wait_for_confirmation(algorand.client.algod, delete_app_client_1_txn.tx_id, 10)
    assert (
        delete_app_client_1_txn.confirmed_round
    ), "delete_app_client_1_txn transaction round needs confirmation."

    # Get creator and app account balance after delete method is called
    creator_after_balance = algorand.account.get_information(creator.address)["amount"]
    app_after_balance = algorand.account.get_information(
        app_factory["app_client_1"].app_address
    )["amount"]

    # Log
    logger.info(f"Creator account balance after deletion: {creator_after_balance}")
    logger.info(f"App account balance after deletion: {app_after_balance}")


# Test case: Account opts in to local storage (via ["OptIn"] using the 'opt_in_local_storage()' abimethod)
# def test_account_opt_in(
#     app_factory: dict[str, OpenBallotClient],
#     creator: AddressAndSigner,
#     randy: AddressAndSigner,
#     ) -> None:

#     # Get desired App client from 'app_factory'
#     app_client1 = app_factory["app_client1"]
#     # app_client2 = app_factory["app_client2"]
#     app_client3 = app_factory["app_client3"]

#     # Send transaction
#     creator_opt_in_appclient1_txn = app_client1.opt_in_local_storage(
#         account=creator.address,
#         transaction_parameters=TransactionParameters(foreign_apps=[app_client1.app_id]),
#     )

#     # Verify transaction was confirmed by the network
#     assert (
#         creator_opt_in_appclient1_txn.confirmed_round
#     ), "creator_opt_in_appclient1_txn round successfully confirmed."

#     # Do the same for the randy account by using app_client3 (which references app_client by ID)
#     randy_opt_in_appclient3_txn = app_client3.opt_in_local_storage(
#         account=randy.address,
#         transaction_parameters=TransactionParameters(foreign_apps=[app_client1.app_id]),
#     )

#     # Verify transaction was confirmed by the network
#     assert (
#         randy_opt_in_appclient3_txn.confirmed_round
#     ), "randy_opt_in_appclient3_txn round successfully confirmed."

#     # Log
#     log_local_state_info(app_client1, creator.address, logger)
#     log_local_state_info(app_client1, randy.address, logger)

# Test case: Account opts out of local storage (via ["CloseOut"] using the 'opt_out()' abimethod)
# def test_account_opt_out(
#     algorand: AlgorandClient,
#     app_factory: dict[str, OpenBallotClient],
#     creator: AddressAndSigner,
#     randy: AddressAndSigner,
#     ) -> None:

#     # Get desired App client from 'app_factory'
#     app_client1 = app_factory["app_client1"]
#     # app_client2 = app_clients["app_client2"]
#     app_client3 = app_factory["app_client3"]

#     # Get creator account balance before close out method is called
#     creator_before_balance = algorand.account.get_information(creator.address)["amount"]
#     logger.info(f"Creator account balance before close out: {creator_before_balance}")

#     # Use App client to send a transaction that executes the 'out-out' close out abimethod for creator
#     creator_opt_out_appclient1_txn = app_client1.close_out_opt_out(account=creator.address)

#     # Verify transaction was confirmed by the network
#     assert (
#         creator_opt_out_appclient1_txn.confirmed_round
#     ), "creator_opt_out_appclient1_txn round successfully confirmed."

#     # Get creator account balance after close out method is called
#     creator_after_balance = algorand.account.get_information(creator.address)["amount"]

#     # Log
#     logger.info(f"Creator account balance after close out: {creator_after_balance}")
#     logger.info(f"Global State attributes: {vars(app_client1.get_global_state())}")
#     get_txn_logs(algorand, creator_opt_out_appclient1_txn.tx_id, logger)

#     # Do the same test for randy account
#     randy_before_balance = algorand.account.get_information(randy.address)["amount"]
#     logger.info(f"Randy account balance before close out: {randy_before_balance}")

#     randy_opt_out_appclient1_txn = app_client3.close_out_opt_out(account=randy.address)

#     assert (
#         randy_opt_out_appclient1_txn.confirmed_round
#     ), "randy_opt_out_appclient1_txn round successfully confirmed."

#     randy_after_balance = algorand.account.get_information(randy.address)["amount"]

#     # Log
#     logger.info(f"Randy account balance after close out: {randy_after_balance}")
#     logger.info(f"Global State attributes: {vars(app_client3.get_global_state())}")
#     get_txn_logs(algorand, randy_opt_out_appclient1_txn.tx_id, logger)
