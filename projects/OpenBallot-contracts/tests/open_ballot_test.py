# tests/open_ballot_test.py
import base64
import time
from itertools import islice

import pytest
from algokit_utils import TransactionParameters
from algokit_utils.beta.account_manager import AddressAndSigner
from algokit_utils.beta.algorand_client import AlgorandClient, SuggestedParams
from algosdk.encoding import decode_address, encode_address
from algosdk.transaction import wait_for_confirmation

from smart_contracts.artifacts.open_ballot.open_ballot_client import OpenBallotClient

from .test_utils import read_box_data, setup_logger, setup_stxn

# Setup the logging.Logger
logger = setup_logger()


# Return an instance of the Algorand client from the default localnet config
@pytest.fixture(scope="session")
def algorand() -> AlgorandClient:
    return AlgorandClient.default_local_net()


# Update the suggested parameters for Algorand transactions.
@pytest.fixture(scope="function")
def sp(algorand: AlgorandClient) -> SuggestedParams:
    sp = algorand.get_suggested_params()
    # sp.first = algorand.client.algod.status().get("last-round")
    # sp.last = sp.first + 1000
    return sp


# Create a dispenser account as AddreessAndSigner object that will fund other accounts
@pytest.fixture(scope="session")
def dispenser(algorand: AlgorandClient) -> AddressAndSigner:
    return algorand.account.dispenser()


# Generate a creator account for testing and fund it with some ALGO via the dispenser account
@pytest.fixture(scope="session")
def creator(algorand: AlgorandClient, dispenser: AddressAndSigner) -> AddressAndSigner:
    # Create a random Algorand account to represent the creator account
    creator = algorand.account.random()

    # Setup signed transaction that funds the creator account (dispenser is funding 50 ALGO to creator account address)
    fund_creator_acc = setup_stxn(
        algorand, dispenser, creator.address, 50_000_000
    )  # 100_000 = 0.1 ALGO

    # Send the signed transaction using the Algorand client
    algorand.send.payment(fund_creator_acc)

    # Return the creator account
    return creator


# Create a factory that can generate an arbitrary amount of randy accounts
@pytest.fixture(scope="session")
def randy_factory(algorand: AlgorandClient, dispenser: AddressAndSigner) -> dict:
    # Define the number of randy accounts that will be created and used for testing
    randy_accounts = 18

    # Create a list to store all the randy accounts that were randomly generated by the Algorand client
    randies = [algorand.account.random() for _ in range(randy_accounts)]

    # Create a list to store all the funding amounts (first randy gets 30_000_000, subsequent ones get 1_000_000 less)
    funding_amounts = [30_000_000 - i * 1_000_000 for i in range(randy_accounts)]

    # Take the matching indices of both lists and zip them into a tuple then iterate through a new list of these tuples
    for randy, amount in zip(randies, funding_amounts):
        dispenser_fund_randy_stxn = setup_stxn(
            algorand, dispenser, randy.address, amount
        )  # Prepare signed txn
        algorand.send.payment(
            dispenser_fund_randy_stxn
        )  # Send signed txn through the Algorand client
        logger.info(f"Funding {randy.address} with {amount} mAlgo")

    # Return a dict with all randy accounts (output: dict[str, AddressAndSigner])
    return {f"randy_{i+1}": randy for i, randy in enumerate(randies)}


# Create an app factory that can return several instances of the smart contract app client for testing
@pytest.fixture(scope="session")
def app_factory(
    algorand: AlgorandClient,
    creator: AddressAndSigner,
    randy_factory: dict[str, AddressAndSigner],
) -> dict:

    # Initialize new dict with creator client (named "app_client_1") as its first element
    app_clients = {
        "app_client_1": OpenBallotClient(
            algod_client=algorand.client.algod,
            sender=creator.address,
            signer=creator.signer,
            template_values={"DELETABLE": 1, "VERSION_UNIX": int(time.time())},
        )
    }

    # Use app_client_1 to send a transaction that generates a new smart contract using the 'Create' on-complete method
    creator_gen_app_client_1_txn = app_clients["app_client_1"].create_generate()

    # Verify transaction was confirmed by the network
    wait_for_confirmation(algorand.client.algod, creator_gen_app_client_1_txn.tx_id, 10)
    assert (
        creator_gen_app_client_1_txn.confirmed_round
    ), "creator_gen_app_client_1_txn transaction round needs confirmation."

    # Log
    logger.info(
        f"APP CLIENT 1 ID: {app_clients["app_client_1"].app_id}"
    )  #  Check client 1 app ID
    logger.info(  # Check client 1 Global State
        f"App Client 1 Global State: {vars(app_clients["app_client_1"].get_global_state())}"
    )

    # Attempt to deploy app_client_1 idempotently
    # app_clients["app_client_1"].deploy(
    #     version="alpha",
    #     create_args=create_args,
    #     delete_args=delete_args,
    #     on_update="append",  # Handle updates by appending new changes
    #     on_schema_break="fail",  # Fail if schema incompatibility occurs
    #     template_values={"DELETABLE": 1, "VERSION_UNIX": int(time.time())},,  # Deployment-time dynamic parameters
    #     allow_update=None,
    #     allow_delete=True,
    # )

    # Add additional app clients (using each randy account as the sender and signer for their own client)
    """OpenBallotClient can be created with an app_id to interact with an already existing application.
    Below, the 'Randy' accounts are creating their own instance of the smart contract client where they are the sender
    and signer, while passing 'Creator' account app_client_1 by its ID in order to interact with it."""
    for i, randy in enumerate(randy_factory.values(), start=2):
        app_clients[f"app_client_{i}"] = OpenBallotClient(
            algod_client=algorand.client.algod,
            sender=randy.address,
            signer=randy.signer,
            app_id=app_clients["app_client_1"].app_id,
            template_values={"DELETABLE": 1, "VERSION_UNIX": int(time.time())},
        )

    # Log
    logger.info(app_clients)

    # Return a dict with all app clients (output: dict[str, OpenBallotClient])
    return app_clients


# Test case: Creator sets poll data (via default ["NoOp"] using the 'set_poll()' abimethod)
def test_set_poll(
    algorand: AlgorandClient,
    app_factory: dict[str, OpenBallotClient],
) -> None:

    # Poll data (title, choice1, choice2, choice3) is algopy.Bytes type and can be passed as byte literals
    title = (
        b"01234567890123456789012345678901234567890123456789012345678"
        b"90123456789012345678901234567890123456789012345678901234567"
    )  # 118 bytes in size

    choice1 = (
        b"0123456789012345678901234567890123456789012345678901234567"
        b"8901234567890123456789012345678901234567890123456789012345"
    )  # 116 bytes in size

    choice2 = b"Twice"
    choice3 = b""

    # Define date format (second/minute/hour/day/month/year)
    date_format = "%S/%M/%H/%d/%m/%Y"

    # Set start date as str within acceptable params of the smart contract 'set_poll()' abimethod
    start_date_str = "00/00/00/10/02/2025"  # 00:00:00 on February 10, 2005
    start_date_unix = int(
        time.mktime(time.strptime(start_date_str, date_format))
    )  # Obtain start date unix via time module by passing the start date string and the date format

    # Set enddate as str within acceptable params
    end_date_str = "00/00/00/22/02/2025"  # 00:00:00 on February 22, 2025
    end_date_unix = int(
        time.mktime(time.strptime(end_date_str, date_format))
    )  # Obtain end date unix via time module by passing the start date string and the date format

    # Send transaction that calls the set_poll abimethod
    set_poll_txn = app_factory["app_client_1"].set_poll(
        title=title,
        choice1=choice1,
        choice2=choice2,
        choice3=choice3,
        start_date_unix=start_date_unix,
        end_date_unix=end_date_unix,
    )

    # Verify transaction was confirmed by the network
    wait_for_confirmation(algorand.client.algod, set_poll_txn.tx_id, 10)
    assert (
        set_poll_txn.confirmed_round
    ), "set_poll_txn transaction round needs confirmation."

    # Log
    logger.info("SET POLL WAS HERE")


# Test case: Creator funds smart contract address with enough to cover its minimum balance and creator box storage MBR
def test_fund_app_mbr(
    algorand: AlgorandClient,
    sp: SuggestedParams,
    app_factory: dict[str, OpenBallotClient],
    creator: AddressAndSigner,
) -> None:

    # Send transaction that calls the fund_app_mbr abimethod
    fund_app_mbr_txn = app_factory["app_client_1"].fund_app_mbr(
        mbr_pay=setup_stxn(
            algorand, creator, app_factory["app_client_1"].app_address, 116_900
        ),  # 100_000 (Global.min_balance) + 16_900 (Box fee)
        transaction_parameters=TransactionParameters(
            suggested_params=sp, boxes=[(0, b"a_" + decode_address(creator.address))]
        ),
    )

    # Verify transaction was confirmed by the network
    wait_for_confirmation(algorand.client.algod, fund_app_mbr_txn.tx_id, 10)
    assert (
        fund_app_mbr_txn.confirmed_round
    ), "fund_app_mbr_txn transaction round needs confirmation."

    # Read box storage data
    read_box_data(
        algorand,
        app_factory["app_client_1"].app_id,
        b"a_" + decode_address(creator.address),
        logger,
    )

    # Log
    logger.info(
        f"APP CLIENT 1 ID: {app_factory["app_client_1"].app_id}"
    )  #  Check client 1 app ID
    logger.info(  # Check client 1 Global State
        f"App Client 1 Global State: {vars(app_factory["app_client_1"].get_global_state())}"
    )


# Test case: Multiple randy accounts request box storage access by paying box storage MBR
def test_request_box_storage(
    algorand: AlgorandClient,
    sp: SuggestedParams,
    app_factory: dict[str, OpenBallotClient],
    randy_factory: dict[str, AddressAndSigner],
) -> None:

    # Iterate over randy accounts and their app clients (excluding the creator's app client).
    for (randy_name, randy), (app_name, app_client) in zip(
        randy_factory.items(), list(app_factory.items())[1:]
    ):
        logger.info(
            f"Testing Request Box Storage abimethod for: {randy_name} using {app_name}"
        )

        # Send transaction that calls the request_box_storage abimethod
        req_box_txn = app_client.request_box_storage(
            mbr_pay=setup_stxn(
                algorand, randy, app_client.app_address, 16_900
            ),  # Box fee of 16,900 micro Algos
            transaction_parameters=TransactionParameters(
                suggested_params=sp,
                boxes=[
                    (0, b"a_" + decode_address(randy.address))
                ],  # List referencing App ID and Box name
            ),
        )

        # Verify transaction was confirmed by the network
        wait_for_confirmation(algorand.client.algod, req_box_txn.tx_id, 10)
        assert (
            req_box_txn.confirmed_round
        ), "req_box_txn transaction round needs confirmation."

        # Log
        read_box_data(
            algorand, app_client.app_id, b"a_" + decode_address(randy.address), logger
        )

    # Log
    app_boxes = algorand.client.algod.application_boxes(
        app_factory["app_client_1"].app_id
    )
    logger.info(f"app boxes array: {app_boxes["boxes"]}")
    logger.info(f"num of app boxes: {len(app_boxes["boxes"])}")

    logger.info(
        f"APP CLIENT 1 ID: {app_factory["app_client_1"].app_id}"
    )  #  Check client 1 app ID
    logger.info(  # Check client 1 Global State
        f"App Client 1 Global State: {vars(app_factory["app_client_1"].get_global_state())}"
    )


# Test case: Multiple randy accounts submit vote (via default ["NoOp"] using the 'submit_vote()' abimethod)
def test_submit_vote(
    algorand: AlgorandClient,
    sp: SuggestedParams,
    creator: AddressAndSigner,
    app_factory: dict[str, OpenBallotClient],
    randy_factory: dict[str, AddressAndSigner],
) -> None:

    # Define a helper inner function to submit a vote and verify the transaction
    def submit_and_verify_vote(
        app_client: OpenBallotClient, voter: AddressAndSigner, choice: int
    ):
        submit_vote_txn = app_client.submit_vote(
            choice=choice,
            transaction_parameters=TransactionParameters(
                suggested_params=sp, boxes=[(0, b"a_" + decode_address(voter.address))]
            ),
        )
        wait_for_confirmation(algorand.client.algod, submit_vote_txn.tx_id, 10)
        assert (
            submit_vote_txn.confirmed_round
        ), f"{voter.address} submit_vote_txn transaction round needs confirmation."

    # Submit and verify votes for creator and randy accounts
    votes = [
        (app_factory["app_client_1"], creator, 3),
        (app_factory["app_client_2"], randy_factory["randy_1"], 2),
        (app_factory["app_client_3"], randy_factory["randy_2"], 1),
        (app_factory["app_client_4"], randy_factory["randy_3"], 3),
        (app_factory["app_client_5"], randy_factory["randy_4"], 1),
        (app_factory["app_client_6"], randy_factory["randy_5"], 1),
        (app_factory["app_client_7"], randy_factory["randy_6"], 1),
    ]

    for app_client, voter, choice in votes:
        submit_and_verify_vote(app_client, voter, choice)

    # Read box data for creator and all randies
    logger.info(f"Reading Box Storage values for {app_factory['app_client_1']}")
    read_box_data(
        algorand,
        app_factory["app_client_1"].app_id,
        b"a_" + decode_address(creator.address),
        logger,
    )
    for randy in randy_factory.values():
        read_box_data(
            algorand,
            app_factory["app_client_1"].app_id,
            b"a_" + decode_address(randy.address),
            logger,
        )

    # Log Global State
    logger.info(
        f"Global State attributes: {vars(app_factory['app_client_1'].get_global_state())}"
    )


# Test case: Multiple randy accounts each delete their box storage each and get their paid MBR refunded
def test_delete_box_storage(
    algorand: AlgorandClient,
    sp: SuggestedParams,
    app_factory: dict[str, OpenBallotClient],
    randy_factory: dict[str, AddressAndSigner],
) -> None:

    # Iterate over randy accounts and their app clients (excluding the creator's app client).
    for (randy_name, randy), (app_name, app_client) in zip(
        # randy_factory.items(),
        # list(app_factory.items())[1:],
        list(randy_factory.items())[:-5], list(app_factory.items())[1:-5]):
        logger.info(
            f"Testing Delete Box Storage abimethod for: {randy_name} using {app_name}"
        )

        # Send transaction that calls the delete_box_storage abimethod
        del_box_txn = app_client.delete_box_storage(
            transaction_parameters=TransactionParameters(
                suggested_params=sp,
                boxes=[
                    (0, b"a_" + decode_address(randy.address))
                ],  # List referencing App ID and Box name
            ),
        )

        # Verify transaction was confirmed by the network
        wait_for_confirmation(algorand.client.algod, del_box_txn.tx_id, 10)
        assert (
            del_box_txn.confirmed_round
        ), "del_box_txn transaction round needs confirmation."

    # Log
    app_boxes = algorand.client.algod.application_boxes(
        app_factory["app_client_1"].app_id
    )
    logger.info(f"app boxes array: {app_boxes["boxes"]}")
    logger.info(f"num of app boxes: {len(app_boxes["boxes"])}")

    logger.info(
        f"APP CLIENT 1 ID: {app_factory["app_client_1"].app_id}"
    )  #  Check client 1 app ID
    logger.info(  # Check client 1 Global State
        f"App Client 1 Global State: {vars(app_factory["app_client_1"].get_global_state())}"
    )


# Test case: Creator executes box storage purge (NOTE: Refactor to search boxes by indexer instead of looping randies)
def test_purge_box_storage(
    algorand: AlgorandClient,
    sp: SuggestedParams,
    creator: AddressAndSigner,
    app_factory: dict[str, OpenBallotClient],
) -> None:

    logger.info("Testing Purge Box Storage abimethod:")

    app_boxes = algorand.client.algod.application_boxes(
        app_factory["app_client_1"].app_id
    )

    # Log
    logger.info(f"app boxes array: {app_boxes["boxes"]}")
    logger.info(f"num of app boxes: {len(app_boxes["boxes"])}")

    # Prepare randy addresses list by decoding box names and extracting last 32 bytes
    randy_addresses = []
    for box in app_boxes["boxes"]:
        box_key = base64.b64decode(box["name"])
        address = encode_address(box_key[-32:])
        if address != creator.address:
            randy_addresses.append(address)

    # Prepare box keys in batches
    box_key_batches = [
        [
            decode_address(randy_address)
            for randy_address in islice(randy_addresses, i, i + 8)
        ]
        for i in range(0, len(randy_addresses), 8)
    ]

    # Track num of total batches
    box_keys_batch_count = len(box_key_batches)

    # Proccess box keys batches until empty
    while box_key_batches:
        logger.info(f"Box_key_batches: {box_key_batches}")
        batch = box_key_batches.pop(
            0
        )  # Batch equals first removed index of box keys batches
        batch_id = box_keys_batch_count - len(box_key_batches)

        # Log
        logger.info(f"Current batch contents in bytes: {batch}")

        logger.info(
            f"Total remaining batches left to process: {len(box_key_batches) + 1}"
        )
        logger.info(
            f"Total remaining boxes left to process: {sum(len(b) for b in box_key_batches) + len(batch)}"
        )
        logger.info(f"Processing box key batch: {batch_id}/{box_keys_batch_count}")

        # Send transaction that calls the purge_box_storage abimethod
        purge_box_storage_txn = app_factory["app_client_1"].purge_box_storage(
            box_keys=batch,
            transaction_parameters=TransactionParameters(
                suggested_params=sp,
                boxes=[
                    (0, b"a_" + box_key) for box_key in batch
                ],  # List of tuples w/ App ID  + Box key address in batch
            ),
        )

        # Verify transaction was confirmed by the network
        wait_for_confirmation(algorand.client.algod, purge_box_storage_txn.tx_id, 10)
        assert (
            purge_box_storage_txn.confirmed_round
        ), f"purge_box_storage_txn for box key batch {batch_id} transaction round needs confirmation."

    app_boxes = algorand.client.algod.application_boxes(
        app_factory["app_client_1"].app_id
    )

    # Log
    logger.info(f"app boxes array after purge: {app_boxes["boxes"]}")
    logger.info(f"num of app boxes after purge: {len(app_boxes["boxes"])}")

    boxxx0 = base64.b64decode(app_boxes["boxes"][0]["name"])
    # boxxx1 = base64.b64decode(app_boxes["boxes"][1]["name"])
    # boxxx2 = base64.b64decode(app_boxes["boxes"][2]["name"])
    logger.info(boxxx0)
    logger.info(encode_address(boxxx0[-32:]))
    # logger.info(encode_address(boxxx1[-32:]))
    # logger.info(encode_address(boxxx2[-32:]))

    # boxxx = algorand.client.algod.application_box_by_name(app_factory["app_client_1"].app_id, box_title)

    # box_title = base64.b64decode(box["name"])
    # box_value = list(base64.b64decode(box["value"]))

    # #[-2-32:-2]
    # if len(box_title[-32:]) == 32:
    #     addr_base32 = encode_address(box_title[-32:])
    #     logger.info(
    #         f"Address: {addr_base32} using box with key prefix: {box_title[:-32]}"
    #     )

    # logger.info(f"Address: {addr_base32} - VoterData.voted: {box_value[0]}")
    # logger.info(f"Address: {addr_base32} - VoterData.choice: {box_value[1]}")

    logger.info(
        f"APP CLIENT 1 ID: {app_factory["app_client_1"].app_id}"
    )  #  Check client 1 app ID
    logger.info(  # Check client 1 Global State
        f"App Client 1 Global State: {vars(app_factory["app_client_1"].get_global_state())}"
    )


# Test case: Creator deletes app client (via ["DeleteApplication"] 'terminate' abimethod & gets purged box MBR if any)
def test_delete_app(
    algorand: AlgorandClient,
    sp: SuggestedParams,
    app_factory: dict[str, OpenBallotClient],
    creator: AddressAndSigner,
) -> None:

    # Get creator and app account balances before the delete method is called
    creator_before_balance = algorand.account.get_information(creator.address)["amount"]
    app_before_balance = algorand.account.get_information(
        app_factory["app_client_1"].app_address
    )["amount"]

    # Log
    logger.info(f"Creator account balance before deletion: {creator_before_balance}")
    logger.info(f"App account balance before deletion: {app_before_balance}")

    # Use App client to send a transaction that executes the 'terminate' delete application abimethod
    delete_app_client_1_txn = app_factory["app_client_1"].delete_terminate(
        transaction_parameters=TransactionParameters(
            suggested_params=sp, boxes=[(0, b"a_" + decode_address(creator.address))]
        )
    )

    wait_for_confirmation(algorand.client.algod, delete_app_client_1_txn.tx_id, 10)
    assert (
        delete_app_client_1_txn.confirmed_round
    ), "delete_app_client_1_txn transaction round needs confirmation."

    # Get creator and app account balance after delete method is called
    creator_after_balance = algorand.account.get_information(creator.address)["amount"]
    app_after_balance = algorand.account.get_information(
        app_factory["app_client_1"].app_address
    )["amount"]

    # Log
    logger.info(f"Creator account balance after deletion: {creator_after_balance}")
    logger.info(f"App account balance after deletion: {app_after_balance}")


# Test case: Account opts in to local storage (via ["OptIn"] using the 'opt_in_local_storage()' abimethod)
# def test_account_opt_in(
#     app_factory: dict[str, OpenBallotClient],
#     creator: AddressAndSigner,
#     randy: AddressAndSigner,
#     ) -> None:

#     # Get desired App client from 'app_factory'
#     app_client1 = app_factory["app_client1"]
#     # app_client2 = app_factory["app_client2"]
#     app_client3 = app_factory["app_client3"]

#     # Send transaction
#     creator_opt_in_appclient1_txn = app_client1.opt_in_local_storage(
#         account=creator.address,
#         transaction_parameters=TransactionParameters(foreign_apps=[app_client1.app_id]),
#     )

#     # Verify transaction was confirmed by the network
#     assert (
#         creator_opt_in_appclient1_txn.confirmed_round
#     ), "creator_opt_in_appclient1_txn round successfully confirmed."

#     # Do the same for the randy account by using app_client3 (which references app_client by ID)
#     randy_opt_in_appclient3_txn = app_client3.opt_in_local_storage(
#         account=randy.address,
#         transaction_parameters=TransactionParameters(foreign_apps=[app_client1.app_id]),
#     )

#     # Verify transaction was confirmed by the network
#     assert (
#         randy_opt_in_appclient3_txn.confirmed_round
#     ), "randy_opt_in_appclient3_txn round successfully confirmed."

#     # Log
#     log_local_state_info(app_client1, creator.address, logger)
#     log_local_state_info(app_client1, randy.address, logger)

# Test case: Account opts out of local storage (via ["CloseOut"] using the 'opt_out()' abimethod)
# def test_account_opt_out(
#     algorand: AlgorandClient,
#     app_factory: dict[str, OpenBallotClient],
#     creator: AddressAndSigner,
#     randy: AddressAndSigner,
#     ) -> None:

#     # Get desired App client from 'app_factory'
#     app_client1 = app_factory["app_client1"]
#     # app_client2 = app_clients["app_client2"]
#     app_client3 = app_factory["app_client3"]

#     # Get creator account balance before close out method is called
#     creator_before_balance = algorand.account.get_information(creator.address)["amount"]
#     logger.info(f"Creator account balance before close out: {creator_before_balance}")

#     # Use App client to send a transaction that executes the 'out-out' close out abimethod for creator
#     creator_opt_out_appclient1_txn = app_client1.close_out_opt_out(account=creator.address)

#     # Verify transaction was confirmed by the network
#     assert (
#         creator_opt_out_appclient1_txn.confirmed_round
#     ), "creator_opt_out_appclient1_txn round successfully confirmed."

#     # Get creator account balance after close out method is called
#     creator_after_balance = algorand.account.get_information(creator.address)["amount"]

#     # Log
#     logger.info(f"Creator account balance after close out: {creator_after_balance}")
#     logger.info(f"Global State attributes: {vars(app_client1.get_global_state())}")
#     get_txn_logs(algorand, creator_opt_out_appclient1_txn.tx_id, logger)

#     # Do the same test for randy account
#     randy_before_balance = algorand.account.get_information(randy.address)["amount"]
#     logger.info(f"Randy account balance before close out: {randy_before_balance}")

#     randy_opt_out_appclient1_txn = app_client3.close_out_opt_out(account=randy.address)

#     assert (
#         randy_opt_out_appclient1_txn.confirmed_round
#     ), "randy_opt_out_appclient1_txn round successfully confirmed."

#     randy_after_balance = algorand.account.get_information(randy.address)["amount"]

#     # Log
#     logger.info(f"Randy account balance after close out: {randy_after_balance}")
#     logger.info(f"Global State attributes: {vars(app_client3.get_global_state())}")
#     get_txn_logs(algorand, randy_opt_out_appclient1_txn.tx_id, logger)
