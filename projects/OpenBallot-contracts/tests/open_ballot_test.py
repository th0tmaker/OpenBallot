# tests/open_ballot_test.py
import base64
import time
from itertools import islice

import pytest
from algokit_utils import TransactionParameters
from algokit_utils.beta.account_manager import AddressAndSigner
from algokit_utils.beta.algorand_client import AlgorandClient, SuggestedParams
from algosdk.encoding import decode_address, encode_address
from algosdk.transaction import wait_for_confirmation

from smart_contracts.artifacts.open_ballot.open_ballot_client import OpenBallotClient

from .test_utils import read_box_data, setup_logger, setup_stxn

# Setup the logging.Logger
logger = setup_logger()


# Return an instance of the Algorand client from the default localnet config
@pytest.fixture(scope="session")
def algorand() -> AlgorandClient:
    return AlgorandClient.default_local_net()

# Update the suggested parameters for Algorand transactions.
@pytest.fixture(scope="function")
def sp(algorand: AlgorandClient) -> SuggestedParams:
    sp = algorand.client.algod.suggested_params()
    sp.flat_fee = True
    sp.fee = 1000
    sp.first = algorand.client.algod.status().get("last-round")
    sp.last = sp.first + 1000
    return sp

# Create a dispenser account as AddreessAndSigner object that will fund other accounts
@pytest.fixture(scope="session")
def dispenser(algorand: AlgorandClient) -> AddressAndSigner:
    return algorand.account.dispenser()

# Generate a creator account for testing and fund it with some ALGO via the dispenser account
@pytest.fixture(scope="session")
def creator(algorand: AlgorandClient, dispenser: AddressAndSigner) -> AddressAndSigner:
    # Create a random Algorand account to represent the creator account
    creator = algorand.account.random()

    # Setup signed transaction that funds the creator account (dispenser is funding 50 ALGO to creator account address)
    fund_creator_acc = setup_stxn(algorand, dispenser, creator.address, 50_000_000)  # 100_000 = 0.1 ALGO

    # Send the signed transaction using the Algorand client
    algorand.send.payment(fund_creator_acc)

    # Return the creator account
    return creator

# Create a factory that can generate an arbitrary amount of dummy accounts
@pytest.fixture(scope="session")
def dummy_factory(algorand: AlgorandClient, dispenser: AddressAndSigner) -> dict:
    # Define the number of dummy accounts that will be created and used for testing
    dummy_accounts = 18

    # Create a list to store all the dummy accounts that were randomly generated by the Algorand client
    dummies = [algorand.account.random() for _ in range(dummy_accounts)]

    # Create a list to store all the funding amounts (first dummy gets 30_000_000, subsequent ones get 1_000_000 less)
    funding_amounts = [30_000_000 - i * 1_000_000 for i in range(dummy_accounts)]

    # Take the matching indices of both lists and zip them into a tuple then iterate through a new list of these tuples
    for dummy, amount in zip(dummies, funding_amounts):
        dispenser_fund_dummy_stxn = setup_stxn(algorand, dispenser, dummy.address, amount)  # Prepare signed txn
        algorand.send.payment(dispenser_fund_dummy_stxn)  # Send signed txn through the Algorand client
        logger.info(f"Funding {dummy.address} with {amount} microAlgos")

    # Return a dict with all dummy accounts (output: dict[str, AddressAndSigner])
    return {f"dummy_{i+1}": dummy for i, dummy in enumerate(dummies)}

# Create an app factory that can return several instances of the smart contract app client for testing
@pytest.fixture(scope="session")
def app_factory(
    algorand: AlgorandClient, creator: AddressAndSigner, dummy_factory: dict[str, AddressAndSigner],) -> dict:

    # Initialize new dict with creator client (named "app_client_1") as its first element
    app_clients = {
        "app_client_1": OpenBallotClient(
            algod_client=algorand.client.algod,
            sender=creator.address,
            signer=creator.signer,
            template_values={"DELETABLE": 1, "VERSION_UNIX": int(time.time())},
        )
    }

    # Use app_client_1 to send a transaction that generates a new smart contract using the 'Create' on-complete method
    creator_gen_app_client_1_txn = app_clients["app_client_1"].create_generate()

    # Verify transaction was confirmed by the network
    wait_for_confirmation(algorand.client.algod, creator_gen_app_client_1_txn.tx_id, 10)
    assert (
        creator_gen_app_client_1_txn.confirmed_round
    ), "creator_gen_app_client_1_txn transaction round needs confirmation."

    # Log
    logger.info(f"APP CLIENT 1 ID: {app_clients["app_client_1"].app_id}")  #  Check client 1 app ID
    logger.info(  # Check client 1 Global State
        f"App Client 1 Global State: {vars(app_clients["app_client_1"].get_global_state())}"
    )

    # Attempt to deploy app_client_1 idempotently
    # app_clients["app_client_1"].deploy(
    #     version="alpha",
    #     create_args=create_args,
    #     delete_args=delete_args,
    #     on_update="append",  # Handle updates by appending new changes
    #     on_schema_break="fail",  # Fail if schema incompatibility occurs
    #     template_values={"DELETABLE": 1, "VERSION_UNIX": int(time.time())},,  # Deployment-time dynamic parameters
    #     allow_update=None,
    #     allow_delete=True,
    # )

    # Add additional app clients (using each dummy account as the sender and signer for their own client)
    """OpenBallotClient can be created with an app_id to interact with an already existing application.
    Below, the 'Dummy' accounts are creating their own instance of the smart contract client where they are the sender
    and signer, while passing 'Creator' account app_client_1 by its ID in order to interact with it."""
    for i, dummy in enumerate(dummy_factory.values(), start=2):
        app_clients[f"app_client_{i}"] = OpenBallotClient(
            algod_client=algorand.client.algod,
            sender=dummy.address,
            signer=dummy.signer,
            app_id=app_clients["app_client_1"].app_id,
            template_values={"DELETABLE": 1, "VERSION_UNIX": int(time.time())},
        )

    # Log
    logger.info(app_clients)

    # Return a dict with all app clients (output: dict[str, OpenBallotClient])
    return app_clients

# Test case: Creator sets poll data (via default ["NoOp"] using the 'set_poll()' abimethod)
def test_set_poll(
    algorand: AlgorandClient,
    app_factory: dict[str, OpenBallotClient],
) -> None:

    # Poll data (title, choice1, choice2, choice3) is algopy.Bytes type and can be passed as byte literals
    title = (
        b"01234567890123456789012345678901234567890123456789012345678"
        b"90123456789012345678901234567890123456789012345678901234567"
    )  # 118 bytes in size

    choice1 = (
        b"0123456789012345678901234567890123456789012345678901234567"
        b"8901234567890123456789012345678901234567890123456789012345"
    )  # 116 bytes in size

    choice2 = b"Twice"
    choice3 = b""

    # Define date format (second/minute/hour/day/month/year)
    date_format = "%S/%M/%H/%d/%m/%Y"

    # Set start date as str within acceptable params of the smart contract 'set_poll()' abimethod
    start_date_str = "00/00/00/05/02/2025"  # 00:00:00 on February 5, 2005
    start_date_unix = int(
        time.mktime(time.strptime(start_date_str, date_format))
    )  # Obtain start date unix via time module by passing the start date string and the date format

    # Set enddate as str within acceptable params
    end_date_str = "00/00/00/18/02/2025"  # 00:00:00 on February 18, 2025
    end_date_unix = int(
        time.mktime(time.strptime(end_date_str, date_format))
    )  # Obtain end date unix via time module by passing the start date string and the date format

    # Send transaction that calls the set_poll abimethod
    set_poll_txn = app_factory["app_client_1"].set_poll(
        title=title,
        choice1=choice1,
        choice2=choice2,
        choice3=choice3,
        start_date_unix=start_date_unix,
        end_date_unix=end_date_unix,
    )

    # Verify transaction was confirmed by the network
    wait_for_confirmation(algorand.client.algod, set_poll_txn.tx_id, 10)
    assert (
        set_poll_txn.confirmed_round
    ), "set_poll_txn transaction round needs confirmation."

    # Log
    logger.info("SET POLL WAS HERE")

# Test case: Creator funds smart contract address with enough to cover its minimum balance and creator box storage MBR
def test_fund_app_mbr(
    algorand: AlgorandClient,
    sp: SuggestedParams,
    app_factory: dict[str, OpenBallotClient],
    creator: AddressAndSigner,
) -> None:

    # Send transaction that calls the fund_app_mbr abimethod
    fund_app_mbr_txn = app_factory["app_client_1"].fund_app_mbr(
        mbr_pay=setup_stxn(
            algorand,
            creator,
            app_factory["app_client_1"].app_address,
            116_900),  # 100_000 (Global.min_balance) + 16_900 (Box fee)
        transaction_parameters=TransactionParameters(
            suggested_params=sp,
            boxes=[(0, b"a_" + decode_address(creator.address))]
        )
    )

    # Verify transaction was confirmed by the network
    wait_for_confirmation(algorand.client.algod, fund_app_mbr_txn.tx_id, 10)
    assert (
        fund_app_mbr_txn.confirmed_round
    ), "fund_app_mbr_txn transaction round needs confirmation."

    # Read box storage data
    read_box_data(algorand, app_factory["app_client_1"].app_id, b"a_" + decode_address(creator.address), logger)

    # Log
    logger.info(f"APP CLIENT 1 ID: {app_factory["app_client_1"].app_id}")  #  Check client 1 app ID
    logger.info(  # Check client 1 Global State
        f"App Client 1 Global State: {vars(app_factory["app_client_1"].get_global_state())}"
    )

# Test case: Multiple dummy accounts request box storage access by paying box storage MBR
def test_request_box_storage(
    algorand: AlgorandClient,
    sp: SuggestedParams,
    app_factory: dict[str, OpenBallotClient],
    dummy_factory: dict[str, AddressAndSigner],
) -> None:

    # Iterate over dummy accounts and their app clients (excluding the creator's app client).
    for (dummy_name, dummy), (app_name, app_client) in zip(dummy_factory.items(), list(app_factory.items())[1:]):
        logger.info(f"Testing Request Box Storage abimethod for: {dummy_name} using {app_name}")

        # Send transaction that calls the request_box_storage abimethod
        req_box_txn = app_client.request_box_storage(
            mbr_pay=setup_stxn(algorand, dummy, app_client.app_address, 16_900),  # Box fee of 16,900 micro Algos
            transaction_parameters=TransactionParameters(
                suggested_params=sp,
                boxes=[(0, b"a_" + decode_address(dummy.address))]  # List referencing App ID and Box name
            )
        )

        # Verify transaction was confirmed by the network
        wait_for_confirmation(algorand.client.algod, req_box_txn.tx_id, 10)
        assert (
            req_box_txn.confirmed_round
        ), "req_box_txn transaction round needs confirmation."

        # Log
        read_box_data(algorand, app_client.app_id, b"a_" + decode_address(dummy.address), logger)

    logger.info(f"APP CLIENT 1 ID: {app_factory["app_client_1"].app_id}")  #  Check client 1 app ID
    logger.info(  # Check client 1 Global State
        f"App Client 1 Global State: {vars(app_factory["app_client_1"].get_global_state())}"
    )

# Test case: Creator executes box storage cleanup
def test_cleanup_box_storage(
    algorand: AlgorandClient,
    sp: SuggestedParams,
    app_factory: dict[str, OpenBallotClient],
    dummy_factory: dict[str, AddressAndSigner],
) -> None:

    # Prepare box keys in batches
    box_keys_batch_list = [
        [decode_address(dummy.address) for dummy in islice(dummy_factory.values(), i, i + 8)]
        # for i in (0, 8)  # Select custom range for batch
        for i in range(0, len(dummy_factory.values()), 8)  # -> start=0, stop=num_of_dummies, step=8
    ]

    # Track num of total batches
    box_keys_batch_count = len(box_keys_batch_list)

    # Proccess box keys batch list until empty
    while box_keys_batch_list:
        batch = box_keys_batch_list.pop(0)  # Batch equals first removed index of box keys batch list
        batch_id = box_keys_batch_count - len(box_keys_batch_list)

        # Log
        logger.info(f"Total remaining batches left to process: {len(box_keys_batch_list) + 1}")
        logger.info(f"Total remaining boxes left to process: {sum(len(b) for b in box_keys_batch_list) + len(batch)}")
        logger.info(f"Processing box key batch: {batch_id}/{box_keys_batch_count}")

        # Send transaction that calls the cleanup_box_storage abimethod
        cleanup_box_storage_txn = app_factory["app_client_1"].cleanup_box_storage(
            box_keys=batch,
            transaction_parameters=TransactionParameters(
                suggested_params=sp,
                boxes=[(0, b"a_" + box_key) for box_key in batch]  # List of tuples w/ App ID  + Box names
            )
        )

        # Verify transaction was confirmed by the network
        wait_for_confirmation(algorand.client.algod, cleanup_box_storage_txn.tx_id, 10)
        assert (
            cleanup_box_storage_txn.confirmed_round
        ), f"cleanup_box_storage_txn for box key batch {batch_id} transaction round needs confirmation."

    # Log
    app_boxes = algorand.client.algod.application_boxes(app_factory["app_client_1"].app_id)
    logger.info(f"app boxes array: {app_boxes["boxes"]}")
    logger.info(f"num of app boxes: {len(app_boxes["boxes"])}")

    boxxx0 = base64.b64decode(app_boxes["boxes"][0]["name"])
    # boxxx1 = base64.b64decode(app_boxes["boxes"][1]["name"])
    # boxxx2 = base64.b64decode(app_boxes["boxes"][2]["name"])

    logger.info(encode_address(boxxx0[-32:]))
    # logger.info(encode_address(boxxx1[-32:]))
    # logger.info(encode_address(boxxx2[-32:]))

        # boxxx = algorand.client.algod.application_box_by_name(app_factory["app_client_1"].app_id, box_title)

    # box_title = base64.b64decode(box["name"])
    # box_value = list(base64.b64decode(box["value"]))

    # #[-2-32:-2]
    # if len(box_title[-32:]) == 32:
    #     addr_base32 = encode_address(box_title[-32:])
    #     logger.info(
    #         f"Address: {addr_base32} using box with key prefix: {box_title[:-32]}"
    #     )

    # logger.info(f"Address: {addr_base32} - VoterData.voted: {box_value[0]}")
    # logger.info(f"Address: {addr_base32} - VoterData.choice: {box_value[1]}")

    logger.info(f"APP CLIENT 1 ID: {app_factory["app_client_1"].app_id}")  #  Check client 1 app ID
    logger.info(  # Check client 1 Global State
        f"App Client 1 Global State: {vars(app_factory["app_client_1"].get_global_state())}"
    )

# Test case: Creator deletes app client (via ["DeleteApplication"] 'terminate' abimethod & gets cleanup box MBR if any)
def test_delete_app(
    algorand: AlgorandClient,
    sp: SuggestedParams,
    app_factory: dict[str, OpenBallotClient],
    creator: AddressAndSigner,
    ) -> None:

    # Get creator account balance after delete method is called
    app_before_balance = algorand.account.get_information(app_factory["app_client_1"].app_address)["amount"]

    # Log
    logger.info(f"App account balance before deletion: {app_before_balance}")

    # Get creator account balance before delete method is called
    creator_before_balance = algorand.account.get_information(creator.address)["amount"]
    logger.info(f"Creator account balance before deletion: {creator_before_balance}")

    # creator_del_box_storage_txn = app_factory["app_client_1"].delete_box_storage(
    #         transaction_parameters=TransactionParameters(
    #             suggested_params=sp,
    #             boxes=[b"a_" + decode_address(creator.address)]
    #         )
    #     )

    # # Verify transaction was confirmed by the network
    # wait_for_confirmation(algorand.client.algod, creator_del_box_storage_txn.tx_id, 10)
    # assert (
    #     creator_del_box_storage_txn.confirmed_round
    # ), "creator_del_box_storage_txn round needs confirmation."

    # read_box_data(algorand, app_factory["app_client_1"].app_id, b"a_" + decode_address(creator.address), logger)

    # Use App client to send a transaction that executes the 'terminate' delete application abimethod
    delete_app_client_1_txn = app_factory["app_client_1"].delete_terminate(
            transaction_parameters=TransactionParameters(
                suggested_params=sp,
                boxes=[(0, b"a_" + decode_address(creator.address))]
            )
    )

    wait_for_confirmation(algorand.client.algod, delete_app_client_1_txn.tx_id, 10)
    assert (
        delete_app_client_1_txn.confirmed_round
    ), "delete_app_client_1_txn transaction round needs confirmation."

    # Get creator account balance after delete method is called
    creator_after_balance = algorand.account.get_information(creator.address)["amount"]

    # Log
    logger.info(f"Creator account balance after deletion: {creator_after_balance}")


    # Get creator account balance after delete method is called
    app_after_balance = algorand.account.get_information(app_factory["app_client_1"].app_address)["amount"]

    # Log
    logger.info(f"App account balance after deletion: {app_after_balance}")

# Test case: Account opts in to local storage (via ["OptIn"] using the 'opt_in_local_storage()' abimethod)
# def test_account_opt_in(
#     app_factory: dict[str, OpenBallotClient],
#     creator: AddressAndSigner,
#     dummy: AddressAndSigner,
#     ) -> None:

#     # Get desired App client from 'app_factory'
#     app_client1 = app_factory["app_client1"]
#     # app_client2 = app_factory["app_client2"]
#     app_client3 = app_factory["app_client3"]

#     # Send transaction
#     creator_opt_in_appclient1_txn = app_client1.opt_in_local_storage(
#         account=creator.address,
#         transaction_parameters=TransactionParameters(foreign_apps=[app_client1.app_id]),
#     )

#     # Verify transaction was confirmed by the network
#     assert (
#         creator_opt_in_appclient1_txn.confirmed_round
#     ), "creator_opt_in_appclient1_txn round successfully confirmed."

#     # Do the same for the dummy account by using app_client3 (which references app_client by ID)
#     dummy_opt_in_appclient3_txn = app_client3.opt_in_local_storage(
#         account=dummy.address,
#         transaction_parameters=TransactionParameters(foreign_apps=[app_client1.app_id]),
#     )

#     # Verify transaction was confirmed by the network
#     assert (
#         dummy_opt_in_appclient3_txn.confirmed_round
#     ), "dummy_opt_in_appclient3_txn round successfully confirmed."

#     # Log
#     log_local_state_info(app_client1, creator.address, logger)
#     log_local_state_info(app_client1, dummy.address, logger)


# Test case: Account submits vote (via default ["NoOp"] using the 'submit_vote()' abimethod)
# def test_submit_vote(
#     algorand: AlgorandClient,
#     app_factory: dict[str, OpenBallotClient],
#     creator: AddressAndSigner,
#     dummy: AddressAndSigner,
# ) -> None:

#     # Get desired App client from 'app_factory'
#     app_client1 = app_factory["app_client1"]
#     app_client3 = app_factory["app_client3"]

#     creator_box_a_name = b"a_" + decode_address(creator.address)
#     dummy_box_a_name = b"a_" + decode_address(dummy.address)

#     # Creator uses 'app_client1' to send a txn that executes the 'submit_vote()' abimethod
#     creator_submit_vote_appclient1_txn = app_client1.submit_vote(
#         choice=2,
#         transaction_parameters=TransactionParameters(boxes=[(0, creator_box_a_name)]),
#     )

#     # Verify transaction was confirmed by the network
#     assert (
#         creator_submit_vote_appclient1_txn.confirmed_round
#     ), "creator_submit_vote_appclient1_txn round successfully confirmed."

#     # Dummy uses 'app_client3' (that references 'app_client1') to send a txn that executes the 'submit_vote()' method
#     dummy_submit_vote_appclient1_txn = app_client3.submit_vote(
#         choice=3,
#         transaction_parameters=TransactionParameters(boxes=[(0, dummy_box_a_name)]),
#     )

#     # Verify transaction was confirmed by the network
#     assert (
#         dummy_submit_vote_appclient1_txn.confirmed_round
#     ), "dummy_submit_vote_appclient1_txn round successfully confirmed."

#     # Log
#     logger.info(f"Global State attributes: {vars(app_client1.get_global_state())}")

#     # Read box data
#     read_box_data(algorand, app_client1.app_id, creator_box_a_name, logger)
#     read_box_data(algorand, app_client3.app_id, dummy_box_a_name, logger)


# Test case: Account opts out of local storage (via ["CloseOut"] using the 'opt_out()' abimethod)
# def test_account_opt_out(
#     algorand: AlgorandClient,
#     app_factory: dict[str, OpenBallotClient],
#     creator: AddressAndSigner,
#     dummy: AddressAndSigner,
#     ) -> None:

#     # Get desired App client from 'app_factory'
#     app_client1 = app_factory["app_client1"]
#     # app_client2 = app_clients["app_client2"]
#     app_client3 = app_factory["app_client3"]

#     # Get creator account balance before close out method is called
#     creator_before_balance = algorand.account.get_information(creator.address)["amount"]
#     logger.info(f"Creator account balance before close out: {creator_before_balance}")

#     # Use App client to send a transaction that executes the 'out-out' close out abimethod for creator
#     creator_opt_out_appclient1_txn = app_client1.close_out_opt_out(account=creator.address)

#     # Verify transaction was confirmed by the network
#     assert (
#         creator_opt_out_appclient1_txn.confirmed_round
#     ), "creator_opt_out_appclient1_txn round successfully confirmed."

#     # Get creator account balance after close out method is called
#     creator_after_balance = algorand.account.get_information(creator.address)["amount"]

#     # Log
#     logger.info(f"Creator account balance after close out: {creator_after_balance}")
#     logger.info(f"Global State attributes: {vars(app_client1.get_global_state())}")
#     get_txn_logs(algorand, creator_opt_out_appclient1_txn.tx_id, logger)

#     # Do the same test for dummy account
#     dummy_before_balance = algorand.account.get_information(dummy.address)["amount"]
#     logger.info(f"Dummy account balance before close out: {dummy_before_balance}")

#     dummy_opt_out_appclient1_txn = app_client3.close_out_opt_out(account=dummy.address)

#     assert (
#         dummy_opt_out_appclient1_txn.confirmed_round
#     ), "dummy_opt_out_appclient1_txn round successfully confirmed."

#     dummy_after_balance = algorand.account.get_information(dummy.address)["amount"]

#     # Log
#     logger.info(f"Dummy account balance after close out: {dummy_after_balance}")
#     logger.info(f"Global State attributes: {vars(app_client3.get_global_state())}")
#     get_txn_logs(algorand, dummy_opt_out_appclient1_txn.tx_id, logger)

